input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         weights = np.array([1, 1, 1, 1, 1, 1, 1]) \n         metrics = np.zeros(7) \n         # Heuristics: \n         # positional distance: \n         path_last = node_current.list_paths[-1] \n         distance_last_state = self.calc_heuristic_distance(path_last[-1]) \n         metrics[0] = distance_last_state \n         # velocity difference: \n         goal_state = self.planningProblem.goal.state_list[0] \n         if hasattr(goal_state, 'velocity'): \n             mean_goal_velocity = (goal_state.velocity.start + goal_state.velocity.end) / 2 \n             metrics[1] = abs(path_last[-1].velocity - mean_goal_velocity) \n         # orientation difference: \n         metrics[2] = abs(self.calc_orientation_diff(self.calc_angle_to_goal(path_last[-1]), path_last[-1].orientation)) \n         # time difference: \n         metrics[3] = self.calc_time_cost(path_last) \n         # lanelet id: \n         _, lanelet_id, _ = self.calc_heuristic_lanelet(path_last) \n         if not lanelet_id is None: \n             metrics[4] = 0 if self.is_goal_in_lane(lanelet_id[0]) else 1 \n             # obstacles on lanelet: \n             num_obstacles_on_lenelet = self.num_obstacles_in_lanelet_at_time_step(path_last[-1].time_step, lanelet_id[0]) \n             metrics[5] = num_obstacles_on_lenelet \n             # print(metrics[5]) \n         # trajectory efficiency: \n         metrics[6] = self.calc_path_efficiency(path_last) \n         if metrics[6] == np.inf: \n             return np.inf \n         return sum(weights * metrics)"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Neglect travelled distance
    prescription: Include travelled distance into cost calculation
  improved_heuristic_function: "        def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         weights = np.array([2., 0.4, 1., 0.8, 1., 1., 1., 1.]) \n         metrics = np.zeros(8) \n         # Heuristics: \n         # positional distance: \n         path_last = node_current.list_paths[-1] \n         distance_last_state = self.calc_heuristic_distance(path_last[-1]) \n         metrics[0] = distance_last_state \n         # velocity difference: \n         goal_state = self.planningProblem.goal.state_list[0] \n         if hasattr(goal_state, 'velocity'): \n             mean_goal_velocity = (goal_state.velocity.start + goal_state.velocity.end) / 2 \n             metrics[1] = abs(path_last[-1].velocity - mean_goal_velocity) \n         # orientation difference: \n         if hasattr(goal_state, 'orientation'): \n             metrics[2] = abs(self.calc_orientation_diff(self.calc_angle_to_goal(path_last[-1]), path_last[-1].orientation)) \n         # time difference: \n         metrics[3] = self.calc_time_cost(path_last) \n         # lanelet id: \n         _, lanelet_id, _ = self.calc_heuristic_lanelet(path_last) \n         if not lanelet_id is None: \n             metrics[4] = 0 if self.is_goal_in_lane(lanelet_id[0]) else 1 \n             # obstacles on lanelet: \n             num_obstacles_on_lenelet = self.num_obstacles_in_lanelet_at_time_step(path_last[-1].time_step, lanelet_id[0]) \n             metrics[5] = num_obstacles_on_lenelet \n             # print(metrics[5]) \n         # trajectory efficiency: \n         path_eff = self.calc_path_efficiency(path_last) \n         if np.isclose(path_eff, 0): \n             return np.inf \n         metrics[6] = 0.3*path_eff \n         metrics[7] = 100 - self.calc_travelled_distance(path_last) \n         return sum(weights * metrics) \n "
