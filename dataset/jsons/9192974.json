{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = node_current.list_paths[-1] \n         state = last_path[-1] \n         if self.reached_goal(last_path): \n             return 0.0 \n         distStartState = self.calc_heuristic_distance(last_path[0]) \n         distLastState = self.calc_heuristic_distance(state) \n         if distLastState is None: \n             return np.inf \n         if distStartState < distLastState: \n             return np.inf \n         if self.position_desired is None: \n             return self.time_desired.start - state.time_step \n         velocity_diff = 0 \n         time_diff = min(0, self.time_desired.start - state.time_step) \n         orientation_diff = 0 \n         velocity = state.velocity \n         orientation = state.orientation \n         if np.isclose(velocity, 0): \n             return np.inf \n         if not velocity in self.velocity_desired: \n                 velocity_diff = min(abs(velocity-self.velocity_desired.start), abs(velocity-self.velocity_desired.end)) \n         if not orientation in self.orientation_desired: \n             orientation_diff = min(abs(orientation-self.orientation_desired.start), abs(orientation-self.orientation_desired.end)) \n         distanceToGoal = self.calc_euclidean_distance(current_node=node_current) \n         pathEfficiency = self.calc_path_efficiency(last_path) \n         angleToGoal = self.calc_angle_to_goal(state) \n         steeringAngleDiff = self.calc_orientation_diff(angleToGoal, state.steering_angle) \n         cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(last_path) \n         return (time_diff + 2 * distanceToGoal + distanceToGoal / velocity + 1 / pathEfficiency + velocity_diff + orientation_diff + steeringAngleDiff) \n ",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Zero velocity handling",
            "prescription": "Don't return infinity if velocity is close to zero"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = node_current.list_paths[-1] \n         state = last_path[-1] \n         if self.reached_goal(last_path): \n             return 0.5 \n         if self.position_desired is None: \n             return self.time_desired.start - state.time_step \n         velocity_diff = 0 \n         time_diff = min(0, self.time_desired.start - state.time_step) \n         orientation_diff = 0 \n         velocity = state.velocity \n         orientation = state.orientation \n         #if np.isclose(velocity, 0): \n         #    return np.inf \n         if not velocity in self.velocity_desired: \n             velocity_diff = min(abs(velocity - self.velocity_desired.start), abs(velocity - self.velocity_desired.end)) \n         if not orientation in self.orientation_desired: \n             orientation_diff = min(abs(orientation - self.orientation_desired.start), \n                                    abs(orientation - self.orientation_desired.end)) \n         distanceToGoal = self.calc_euclidean_distance(current_node=node_current) \n         pathEfficiency = self.calc_path_efficiency(last_path) \n         angleToGoal = self.calc_angle_to_goal(state) \n         steeringAngleDiff = self.calc_orientation_diff(angleToGoal, state.steering_angle) \n         #cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(last_path) \n         return (time_diff + 2 * distanceToGoal + (distanceToGoal/velocity)+0.5 + 1 / pathEfficiency + velocity_diff + orientation_diff + steeringAngleDiff) \n "
    }
}