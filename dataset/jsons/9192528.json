{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         current_path = node_current.list_paths[-1] \n         if self.reached_goal(current_path): \n             return -np.inf \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         angle = self.calc_angle_to_goal(current_path[-1]) \n         efficiency = self.calc_path_efficiency(current_path) \n         distance = self.calc_euclidean_distance(node_current) \n         pi_2 = 2. * np.pi \n         normalized_angle = math.fmod(math.fmod(angle, pi_2) + pi_2, pi_2) \n         if normalized_angle > np.pi: \n             normalized_angle -= 2. * np.pi \n         return -efficiency * 5 + distance + abs(normalized_angle) * 10",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost calculation uses arbitrary weights",
            "prescription": "Adjust weights for balance and relevance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         current_path = node_current.list_paths[-1] \n         if self.reached_goal(current_path): \n             return 0.5 \n         time_diff = abs(self.time_desired.start - node_current.list_paths[-1][-1].time_step) \n         if self.position_desired is None: \n             return time_diff \n         if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n             angle = self.calc_angle_to_goal(current_path[-1]) \n             pi_2 = 2. * np.pi \n             normalized_angle = math.fmod(math.fmod(angle, pi_2) + pi_2, pi_2) \n             if normalized_angle > np.pi: \n                 normalized_angle -= 2. * np.pi \n         else: \n             normalized_angle = 0 \n         efficiency = self.calc_path_efficiency(current_path) \n         distance = self.calc_euclidean_distance(node_current) \n         return -efficiency * 0.5 + distance*3 + abs(normalized_angle) * 2 + time_diff"
    }
}