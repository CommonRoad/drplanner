{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 f_time = self.calc_euclidean_distance(current_node=node_current) / velocity \n             ######factor : orientation better be align with the lane orientation \n             orientation = node_current.list_paths[-1][-1].orientation \n             pos = node_current.list_paths[-1][-1].position \n             l_lists = self.scenario.lanelet_network.find_lanelet_by_position([pos])[0] \n             if l_lists: \n                 l_orientations = [abs(orientation - self.calc_lanelet_orientation(l, pos)) for l in l_lists] \n                 # l_ob = [self.calc_dist_to_closest_obstacle(l, pos, ts) for l in l_lists] \n                 min_orientations = min(l_orientations)  # only consider align with any one of the lanelet \n                 # min_ob = min(l_ob) \n             else:  # if not on any lanelet at all \n                 min_orientations = 10 \n             distance = self.calc_heuristic_distance(node_current.list_paths[-1][-1]) \n             eff = self.calc_path_efficiency(node_current.list_paths[-1]) \n             return distance + f_time + min_orientations * 1 - eff",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": [
            {
                "diagnosis": "Zero velocity handling",
                "prescription": "Don't return zero if velocity is close to zero"
            },
            {
                "diagnosis": "Orientation difference always regarding lanelet",
                "prescription": "In case orientation is part of goal state check orientation difference to goal instead"
            },
            {
                "diagnosis": "Zero heuristic for goal",
                "prescription": "Make sure that heuristic returns rational value"
            }
        ],
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             f_time = self.calc_euclidean_distance(current_node=node_current) / velocity \n             ######factor : orientation better be align with the lane orientation \n             orientation = node_current.list_paths[-1][-1].orientation \n             pos = node_current.list_paths[-1][-1].position \n             min_orientations = 0 \n             orientation_diff = 0 \n             if hasattr(self.planningProblem.goal.state_list, 'orientation'): \n                 orientation_diff = self.calc_orientation_diff(self.calc_angle_to_goal(node_current.list_paths[-1][-1]), orientation) \n                 orientation_diff = (orientation_diff + np.pi) % (2 * np.pi) - np.pi \n             else: \n                 l_lists = self.scenario.lanelet_network.find_lanelet_by_position([pos])[0] \n                 if l_lists: \n                     l_orientations = [abs(orientation - self.calc_lanelet_orientation(l, pos)) for l in l_lists] \n                     # l_ob = [self.calc_dist_to_closest_obstacle(l, pos, ts) for l in l_lists] \n                     min_orientations = self.calc_orientation_diff(min(l_orientations), orientation) # only consider align with any one of the lanelet \n                     # min_ob = min(l_ob) \n                 else:  # if not on any lanelet at all \n                     min_orientations = 10 \n             distance = self.calc_heuristic_distance(node_current.list_paths[-1][-1], 5) \n             eff = self.calc_path_efficiency(node_current.list_paths[-1]) \n             return distance + f_time + min_orientations + orientation - eff"
    }
}