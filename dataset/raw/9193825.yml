input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         ######################################################################## \n         # todo: Implement your own heuristic cost calculation here.            # \n         # Hint:                                                                # \n         #   Use the State of the current node and the information from the     # \n         #   planning problem, as well as from the scenario.                    # \n         #   Some helper functions for your convenience can be found in         # \n         #   ./search_algorithms/base_class.py                             # \n         ######################################################################## \n         #print(node_current.priority) \n         #remove states behind goal \n         #node_current.list_paths = self.remove_states_behind_goal(node_current.list_paths) \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if not self.is_collision_free(node_current.list_paths[-1]): \n             return np.inf \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             try: \n                 #get goalstate \n                 goalState = self.planningProblem.goal.state_list[0]  \n                 #set faktor to 1 \n                 faktor = 1 \n                 #positional difference \n                 posiDiff = self.calc_euclidean_distance(current_node=node_current) \n                 #print(posiDiff) \n                 faktor = faktor * posiDiff \n                 #velocity difference \n                 if self.velocity_desired is not None: \n                     velocity = node_current.list_paths[-1][-1].velocity \n                     if np.isclose(velocity, 0): \n                         return np.inf \n                     goalVelo = (self.velocity_desired.start + self.velocity_desired.end) / 2 \n                     velocity_diff = abs(velocity - goalVelo) \n                     #print(velocity_diff) \n                     if velocity_diff == float('inf'): \n                         #print(velocity_diff) \n                         faktor = faktor * 2 \n                 #orientation difference \n                 if self.orientation_desired is not None: \n                     goalOri = (self.orientation_desired.start + self.orientation_desired.end) / 2 \n                     oriDiff = self.calc_orientation_diff(goalOri, node_current.list_paths[-1][-1].orientation) \n                     if oriDiff == float('inf'): \n                         faktor = faktor * 2 \n                 #time difference \n                 goalTime = (goalState.time_step.start + goalState.time_step.end) / 2 \n                 timeDiff = abs(goalTime - node_current.list_paths[-1][-1].time_step) \n                 if timeDiff == float('inf'): \n                     faktor = faktor * 2 \n                 #else: \n                 return faktor / velocity \n                     #return self.calc_heuristic_distance(node_current.list_paths[-1][-1]) / velocity \n             except Exception as e: \n                 print(e) \n "
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Cost calculation uses arbitrary weights
    prescription: Adapt factor weighting for relevance
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         # print(node_current.priority) \n         # remove states behind goal \n         # node_current.list_paths = self.remove_states_behind_goal(node_current.list_paths) \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if len(node_current.list_paths[-1]) > 1 and not self.is_collision_free(node_current.list_paths[-1][1:]): \n             return np.inf \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             try: \n                 # get goalstate \n                 goalState = self.planningProblem.goal.state_list[0] \n                 # set faktor to 1 \n                 faktor = 1 \n                 # positional difference \n                 posiDiff = self.calc_euclidean_distance(current_node=node_current) \n                 # print(posiDiff) \n                 faktor += posiDiff*2 \n                 # velocity difference \n                 velocity = node_current.list_paths[-1][-1].velocity \n                 if velocity not in self.velocity_desired: \n                     goalVelo = (self.velocity_desired.start + self.velocity_desired.end) / 2 \n                     velocity_diff = abs(velocity - goalVelo) \n                     # print(velocity_diff) \n                     if velocity_diff == float('inf'): \n                         # print(velocity_diff) \n                         faktor = faktor * 2 \n                     else: \n                         faktor += velocity_diff*0.5 \n                 # orientation difference \n                 orientation = node_current.list_paths[-1][-1].orientation \n                 if orientation not in self.orientation_desired: \n                     goalOri = (self.orientation_desired.start + self.orientation_desired.end) / 2 \n                     oriDiff = self.calc_orientation_diff(goalOri, orientation) \n                     if oriDiff == float('inf'): \n                         faktor = faktor * 2 \n                     else: \n                         faktor += oriDiff*0.7 \n                 # time difference \n                 time = node_current.list_paths[-1][-1].time_step \n                 if time not in self.time_desired: \n                     goalTime = (goalState.time_step.start + goalState.time_step.end) / 2 \n                     timeDiff = abs(goalTime - time) \n                     if timeDiff == float('inf'): \n                         faktor = faktor * 2 \n                     else: \n                         faktor += timeDiff \n                 # else: \n                 path_eff = self.calc_path_efficiency(node_current.list_paths[-1]) \n                 return faktor - 0.2*path_eff \n                 # return self.calc_heuristic_distance(node_current.list_paths[-1][-1]) / velocity \n             except Exception as e: \n                 print(e) \n "
