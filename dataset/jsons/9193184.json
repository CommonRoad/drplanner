{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path_last = node_current.list_paths[-1] \n         curr_node = path_last[0] \n         distStartState = self.calc_heuristic_distance(path_last[0]) \n         distLastState = self.calc_heuristic_distance(path_last[-1]) \n         if self.reached_goal(node_current.list_paths[-1]): \n             #print('Goal') \n             return 0.0 \n         if distLastState is None: \n             #print('Error distLastState') \n             return np.inf \n         if distStartState < distLastState: \n             #print('Start < Last') \n             return np.inf \n         time_step = path_last[0].time_step \n         if time_step <= self.planningProblem.goal.state_list[0].time_step.start: \n             timestepdiff = abs(time_step-self.planningProblem.goal.state_list[0].time_step.start) \n         elif time_step >= self.planningProblem.goal.state_list[0].time_step.end: \n             #print('infinity') \n             return np.inf \n         else: \n             timestepdiff = 0 \n         '''if timestepdiff == 'None': \n             timestepdiff = 0 \n         print(timestepdiff)''' \n         curPos = curr_node.position \n         curr_lanelet_id = self.scenario.lanelet_network.find_lanelet_by_position([path_last[len(path_last)-1].position])[0] \n         # Weights \n         w = np.zeros(9) \n         we = np.zeros(1) \n         if self.num_obstacles_in_lanelet_at_time_step(time_step, curr_lanelet_id[0]) > 0: \n             dist_obs = self.calc_dist_to_closest_obstacle(curr_lanelet_id[0], np.array([curr_node.position]), time_step) \n             if dist_obs < 40: \n                 crash_factor = 7 \n             elif dist_obs <12: \n                 crash_factor = 20 \n             else: \n                 crash_factor = 1 \n             if curr_node.velocity > 5: \n                 crash_factor = crash_factor*3 \n                 w[3] = 3 #Crash time diff \n             else: \n                 crash_factor = crash_factor \n                 w[3] = 3 #Crash time diff \n         else: \n             w[3] = 0 \n             crash_factor = 0 \n         #print(self.planningProblem.goal.state_list[0].time_step) \n         if self.planningProblem.goal.state_list[0].time_step.start != self.planningProblem.goal.state_list[0].time_step.end: \n             #print(self.scenario.lanelet_network.find_lanelet_by_position([path_last[len(path_last)-1].position])) \n             #print(self.scenario.lanelet_network._lanelets.__dict__) \n             #print(self.scenario.lanelet_network._lanelets[114].right_vertices) \n             #print(self.scenario.lanelet_network._lanelets[114].left_vertices) \n             #print(self.planningProblem.goal.state_list[0].position.shapes[0].vertices) \n             #if hasattr(self.planningProblem.goal.state_list[0].position, 'shapes'): \n              #   goal_vert =self.planningProblem.goal.state_list[0].position.shapes[0].vertices \n             if hasattr(self.planningProblem.goal.state_list[0].position, 'shapes'): \n                 dist_goal = self.calc_euclidean_distance(node_current)    \n                 we[0] = 0 \n                 factor = 1 \n                 w[8] = 8 \n             #print(self.list_ids_lanelets_goal) \n             #Lanelet IDs at the Current State and the goal state \n             #Should be supported by h if goal_lanelet_id = 0 close to the goal \n             else: \n                 goalPos = self.planningProblem.goal.state_list[0].position.center \n                 goal_lanelet_id = self.scenario.lanelet_network.find_lanelet_by_position([goalPos])[0] \n                 dist_goal = self.euclidean_distance(curPos,goalPos) \n                 adj_to_goal = self.find_adjacent_lanelets_same_direction(self.scenario.lanelet_network.find_lanelet_by_id(goal_lanelet_id[0])) \n                 w[8] = 0 \n                 #Weigh if we are close to the goal lanelet \n                 if self.is_goal_in_lane(goal_lanelet_id[0]) or self.is_successor(curr_lanelet_id[0], goal_lanelet_id[0]): \n                     we[0] = 0 \n                 elif self.is_adjacent(curr_lanelet_id[0], goal_lanelet_id[0]): \n                     we[0] = 2 \n                 else: \n                     we[0] = 8 \n                 #is_goal_in_lane(self, goal_lanelet_id , traversed_lanelets=None) #bool \n                 if dist_goal < 5: \n                     factor = 0.0001 \n                 else: \n                     factor = 1 \n             #print(calc_goal_interval(vertices) ) \n             #print(dist_goal) \n             #print(time_step) \n             #print(self.state_initial) \n             # Coupled with current speed -> expected arrival \n             if abs(path_last[0].velocity) > 3: \n                 exp_arr = abs(dist_goal/path_last[0].velocity) \n             else: \n                 exp_arr = 20 \n             #print(self.planningProblem.goal.state_list[0]) \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 #velocitiy of goal \n                 goal_vel = self.planningProblem.goal.state_list[0].velocity \n                 #print(goal_vel) \n                 goal_vel_mean = (goal_vel.start+goal_vel.end)/2 \n                 w[2] = 1*abs(goal_vel_mean-curr_node.velocity) #Velocitiy Diff #Can be Sharpend as there is an interval which is fine \n             else: \n                 w[2] = 0 \n             #distance to obstacle on adjacent lanelet \n             #calc_dist_to_closest_obstacle(self, lanelet_id: int, pos: np.ndarray, time_step: int) \n             #State = self.state_initial \n             #print(State) #\u00c4ndert sich dieser Wert oder ist er der fixt Start Value? Genauso wie oben \n             anglediff_goal = abs(self.calc_angle_to_goal(curr_node)) \n             anglediff_lanelet = abs(self.calc_lanelet_orientation(curr_lanelet_id[0], curPos)) \n             #Adjacent lanelets to Goal \n             # Lanelets which are oriented nearly the same as self \n             #lanelets_of_position(self, scenario.lanelets, state, diff: float = math.pi / 5) \n             # From student_example \n             pathLength = self.calc_travelled_distance(path_last) \n             cost_time = self.calc_time_cost(path_last) \n             def inv_dist(x): \n                 return 5*np.exp(-0.5*x) \n             pathdist, endid, startid =self.calc_heuristic_lanelet(node_current.list_paths[0]) \n             #print(pathdist) \n             #print(len(path_last)) \n             w[0] = 3 #distance to goal \n             w[1] = 0 #Time cost of path             \n             w[4] = 3 #Expected Arrival                    w[4] * exp_arr \n             w[5] = 6 #Goal in right lanelet \n             w[6] = 4 #Angle diff to lanelet \n             w[7] = 3 #Angle diff to goal #Can be Sharpend as there is an interval which is fine \n             #print(pathdist) \n             try: \n                 cost = w[0] * dist_goal +  \n                        w[1] * cost_time +  \n                        w[3] * crash_factor +  \n                        w[4] * exp_arr +  \n                        w[5] * we[0] +  \n                        w[6] * anglediff_lanelet +  \n                        factor*inv_dist(exp_arr)*(w[2]+w[7]*anglediff_goal) +  \n                        w[8] * timestepdiff + 1*pathdist \n             except TypeError: \n                 cost = w[0] * dist_goal +  \n                        w[1] * cost_time +  \n                        w[3] * crash_factor +  \n                        w[4] * exp_arr +  \n                        w[5] * we[0] +  \n                        w[6] * anglediff_lanelet +  \n                        factor*inv_dist(exp_arr)*(w[2]+w[7]*anglediff_goal) +  \n                        w[8] * timestepdiff \n             #print(cost) \n             #print(w[8] * timestepdiff) \n             #print(factor*inv_dist(exp_arr)*(w[2]+w[7]*anglediff_goal)) \n             #print(w[5] * we[0]) \n             #print(w[4] * exp_arr) \n             #print(w[6] * anglediff_lanelet) \n             #print(crash_factor) \n             #print(cost) \n             if hasattr(self.planningProblem.goal.state_list[0].position, 'shapes'): \n                 try: \n                     cost = 6*dist_goal+1*crash_factor+2*pathdist+8*timestepdiff+5*cost_time \n                 except TypeError: \n                     cost = 6*dist_goal+1*crash_factor+8*timestepdiff+5*cost_time \n                 #print(crash_factor) \n                 #print(dist_goal) \n                 #print(pathdist) \n                 #print(timestepdiff) \n                 #print(cost) \n             return cost \n         else: \n             # Distance to obstacle on same lanelet \n             time_step = path_last[0].time_step \n             anglediff_lanelet = self.calc_lanelet_orientation(curr_lanelet_id[0], curPos) \n             # From student_example \n             pathLength = self.calc_travelled_distance(path_last) \n             cost_time = self.calc_time_cost(path_last) \n             w[0] = 0 #Time cost of path \n             w[1] = 1 #time diff \n             w[2] = 3 #Angle diff to lanelet \n             cost = w[2] * abs(anglediff_lanelet) + w[0] * cost_time + w[3] * crash_factor + w[1] * timestepdiff + 2*distStartState \n         return cost",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost calculation uses arbitrary weights",
            "prescription": "Adapt weights of cost function for relevance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path_last = node_current.list_paths[-1] \n         curr_node = path_last[0] \n         factor = 1 \n         distStartState = self.calc_heuristic_distance(path_last[0]) \n         distLastState = self.calc_heuristic_distance(path_last[-1]) \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.5 \n         if distLastState is None: \n             return np.inf \n         if distStartState < distLastState: \n             return np.inf \n         time_step = path_last[0].time_step \n         if time_step < self.planningProblem.goal.state_list[0].time_step.start: \n             timestepdiff = abs(time_step - self.planningProblem.goal.state_list[0].time_step.start) \n         elif time_step > self.planningProblem.goal.state_list[0].time_step.end: \n             return np.inf \n         else: \n             timestepdiff = 0 \n         curPos = curr_node.position \n         curr_lanelet_id = self.scenario.lanelet_network.find_lanelet_by_position([path_last[len(path_last) - 1].position])[0] \n         # Weights \n         w = np.zeros(9) \n         we = np.zeros(1) \n         w[3] = 0 \n         crash_factor = 0 \n         path_efficiency = self.calc_path_efficiency(path_last) \n         pathLength = self.calc_travelled_distance(path_last) \n         if np.isclose(path_efficiency, 0): \n             return np.inf \n         if hasattr(self.planningProblem.goal.state_list[0], 'position'): \n             if hasattr(self.planningProblem.goal.state_list[0].position, 'shapes'): \n                 dist_goal = self.calc_euclidean_distance(node_current) \n                 we[0] = 2 \n                 factor = 1.5 \n                 w[8] = 8 \n             else: \n                 goalPos = self.planningProblem.goal.state_list[0].position.center \n                 goal_lanelet_id = self.scenario.lanelet_network.find_lanelet_by_position([goalPos])[0] \n                 dist_goal = self.calc_euclidean_distance(node_current) \n                 w[8] = 2 \n                 # Weigh if we are close to the goal lanelet \n                 if self.is_goal_in_lane(goal_lanelet_id[0]) or self.is_successor(curr_lanelet_id[0], \n                                                                                  goal_lanelet_id[0]): \n                     we[0] = 0 \n                 elif self.is_adjacent(curr_lanelet_id[0], goal_lanelet_id[0]): \n                     we[0] = 1 \n                 else: \n                     we[0] = 1.5 \n             exp_arr = abs(dist_goal / path_last[0].velocity) \n             vel_diff = 0 \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 goal_vel = self.planningProblem.goal.state_list[0].velocity \n                 goal_vel_mean = (goal_vel.start + goal_vel.end) / 2 \n                 vel_diff = abs(goal_vel_mean - goal_vel) \n                 w[2] = 0.3 \n             else: \n                 w[2] = 0 \n             orientation_diff = 0 \n             orientation = curr_node.orientation \n             if orientation not in self.orientation_desired: \n                 anglediff_goal = self.calc_angle_to_goal(curr_node) \n                 orientation_diff = abs(anglediff_goal - orientation) \n             cost_time = self.calc_time_cost(path_last) \n             w[0] = 2  # distance to goal \n             w[1] = 0.8  # Time cost of path \n             w[4] = 0.5  # Expected Arrival                   \n             w[5] = 10  # Goal in right lanelet \n             w[6] = 1  # Angle diff to lanelet \n             w[8] = 0.4 \n             cost = w[0] * dist_goal + w[1] * cost_time + w[3] * crash_factor + w[4] * exp_arr + w[5] * we[0] + w[6] * orientation_diff + factor * (w[2]*vel_diff) + w[8] * timestepdiff + 100 - pathLength + crash_factor \n         else: cost = timestepdiff - 0.2*path_efficiency + 100 - pathLength \n         return cost \n "
    }
}