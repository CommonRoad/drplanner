{
  "few_shots": [
    {
      "key": "To the chosen trajectory a total penalty of 300.75 was issued. It includes squared sum of acceleration, valued at 192.20; squared sum of steering angle, valued at 0.06; squared sum of steering velocity, valued at 5.51; sum of the path length, valued at 100.05; squared sum of the deviation to the desired velocity, valued at 0.00; squared sum of the deviation to the desired orientation, valued at 0.93. The objective is to decrease this penalty of the planned trajectory to closely align with desired value 0.16.\ndef evaluate(self, trajectory: TrajectorySample) -> float:\n    cost = 0.0\n    cost += 1.0 * self.acceleration_costs(trajectory)\n    cost += 1.0 * self.jerk_costs(trajectory)\n    cost += 1.0 * self.lateral_jerk_costs(trajectory)\n    cost += 1.0 * self.longitudinal_jerk_costs(trajectory)\n    cost += 1.0 * self.orientation_offset_costs(trajectory)\n    cost += 1.0 * self.steering_angle_costs(trajectory)\n    cost += 1.0 * self.steering_velocity_costs(trajectory)\n    cost += 1.0 * self.desired_velocity_costs(trajectory)\n    cost += 1.0 * self.distance_to_reference_path_costs(trajectory)\n    cost += 1.0 * self.desired_path_length_costs(trajectory)\n    cost += 1.0 * self.path_length_costs(trajectory)\n    return cost",
      "value": "General: One of the highest penalties stems from acceleration which is usually caused by frequent/intense actuation of the car's throttle/break.\nSpecific: The current cost function deploys equal weights for every factor but should instead heavily focus on physical quantities causing such driving behaviour.\nStrategy: Significantly increase partial weights for acceleration and all jerk-related factors to effectively punish such trajectories."
    },
    {
      "key": "To the chosen trajectory a total penalty of 300.75 was issued. It includes squared sum of acceleration, valued at 192.20; squared sum of steering angle, valued at 0.06; squared sum of steering velocity, valued at 5.51; sum of the path length, valued at 100.05; squared sum of the deviation to the desired velocity, valued at 0.00; squared sum of the deviation to the desired orientation, valued at 0.93. The objective is to decrease this penalty of the planned trajectory to closely align with desired value 0.16.\ndef evaluate(self, trajectory: TrajectorySample) -> float:\n    cost = 0.0\n    cost += 60.0 * self.acceleration_costs(trajectory)\n    cost += 1.0 * self.jerk_costs(trajectory)\n    cost += 5.0 * self.lateral_jerk_costs(trajectory)\n    cost += 10.0 * self.longitudinal_jerk_costs(trajectory)\n    cost += 100.0 * self.orientation_offset_costs(trajectory)\n    cost += 100.0 * self.steering_angle_costs(trajectory)\n    cost += 1.0 * self.steering_velocity_costs(trajectory)\n    cost += 1.0 * self.desired_velocity_costs(trajectory)\n    cost += 1.0 * self.distance_to_reference_path_costs(trajectory)\n    cost += 1.0 * self.desired_path_length_costs(trajectory)\n    cost += 1.0 * self.path_length_costs(trajectory)\n    return cost",
      "value": "General: One of the highest penalties stems from acceleration which is usually caused by frequent/intense actuation of the car's throttle/break.\nSpecific: Unrelated factors like e.g. steering angle have high weights while cost for jerk is low weighted. Acceleration already has high absolute weights but they might not be high in a relative sense.\nStrategy: Significantly increase weights for  all jerk-related factors. Moderately increase acceleration weights. Decrease all unrelated weights."
    },
    {
      "key": "To the chosen trajectory a total penalty of 300.75 was issued. It includes squared sum of acceleration, valued at 76.23; squared sum of steering angle, valued at 2.43; squared sum of steering velocity, valued at 3.11; sum of the path length, valued at 189.55; squared sum of the deviation to the desired velocity, valued at 0.00; squared sum of the deviation to the desired orientation, valued at 0.93. The objective is to decrease this penalty of the planned trajectory to closely align with desired value 0.16.\ndef evaluate(self, trajectory: TrajectorySample) -> float:\n    cost = 0.0\n    cost += 60.0 * self.acceleration_costs(trajectory)\n    cost += 100.0 * self.jerk_costs(trajectory)\n    cost += 5.0 * self.lateral_jerk_costs(trajectory)\n    cost += 10.0 * self.longitudinal_jerk_costs(trajectory)\n    cost += 8.0 * self.orientation_offset_costs(trajectory)\n    cost += 14.0 * self.steering_angle_costs(trajectory)\n    cost += 6.0 * self.steering_velocity_costs(trajectory)\n    cost += 6.0 * self.desired_velocity_costs(trajectory)\n    cost += 1.0 * self.distance_to_reference_path_costs(trajectory)\n    cost += 1.0 * self.desired_path_length_costs(trajectory)\n    cost += 5.0 * self.path_length_costs(trajectory)\n    return cost",
      "value": "General: The path length seems to be quite large. Even though a trajectories length can not be 0, it might be increased by driving many curves and frequently changing the orientation.\nSpecific: The path length cost has low weight both in an absolute and relative sense. It does not effectively prevent the planner from making bad decisions.\nStrategy: Significantly increase weights for path length. Keep moderate weights for factors related to orientation and steering. Drastically reduce all other weights."
    },
    {
      "key": "To the chosen trajectory a total penalty of 300.75 was issued. It includes squared sum of acceleration, valued at 76.23; squared sum of steering angle, valued at 2.43; squared sum of steering velocity, valued at 3.11; sum of the path length, valued at 189.55; squared sum of the deviation to the desired velocity, valued at 0.00; squared sum of the deviation to the desired orientation, valued at 0.93. The objective is to decrease this penalty of the planned trajectory to closely align with desired value 0.16.\ndef evaluate(self, trajectory: TrajectorySample) -> float:\n    cost = 0.0\n    cost += 1.0 * self.acceleration_costs(trajectory)\n    cost += 1.0 * self.jerk_costs(trajectory)\n    cost += 1.0 * self.lateral_jerk_costs(trajectory)\n    cost += 1.0 * self.longitudinal_jerk_costs(trajectory)\n    cost += 1.0 * self.orientation_offset_costs(trajectory)\n    cost += 1.0 * self.steering_angle_costs(trajectory)\n    cost += 1.0 * self.steering_velocity_costs(trajectory)\n    cost += 1.0 * self.desired_velocity_costs(trajectory)\n    cost += 1.0 * self.distance_to_reference_path_costs(trajectory)\n    cost += 1.0 * self.desired_path_length_costs(trajectory)\n    cost += 50.0 * self.path_length_costs(trajectory)\n    return cost",
      "value": "General: Both penalties for acceleration and path length are very high. The chosen trajectory must be a long one with braking/accelerating many times.\nSpecific: The path length weight seems to already dominate the calculation. Thus, it probably can not be reduced much further and it is better to focus on acceleration-dependant factors.\nStrategy: Keep the weight for path length. Increase weights for acceleration, as well as its derivative (jerk)."
    },
    {
      "key": "!AN EXCEPTION OCCURRED!\nThe planner failed: No optimal trajectory could be found!",
      "value": "General: The planner failed since he could not find any trajectory satisfying the constraints.\nSpecific: Because of constant re-planning, a bad cost function maneuvers the car into a critical state from where it can not continue driving.\nStrategy: Identify extreme weightings inside the cost function and correct them. Adopt a more conservative approach."
    },
    {
      "key": "The planner failed: Planning took too much time and was terminated! The vehicle might be driving to slow or is stuck without moving.",
      "value": "General: Planning took to much time. Therefore, it was terminated and the planner failed.\nSpecific: The vehicle might not be moving. This could be caused by only choosing 0-velocity trajectories.\nStrategy: Increase the weight for desired-velocity to encourage the planner to choose a trajectory which quickly reaches it."
    },
    {
      "key": "!AN EXCEPTION OCCURRED!\n...",
      "value": "General: There is some fundamental problem within the planner. It does not produce any results.\nSpecific: In this case it is difficult to reason about the concrete problem.\nStrategy: Identify extreme weightings inside the cost function and correct them. Adopt a more conservative approach."
    },
    {
      "key": "!AN EXCEPTION OCCURRED!\nname 'acceleration_costs' is not defined\nTYPE: <class 'NameError'> METHOD: run_planner LINE: optimal = planner.plan()",
      "value": "General: Planner fails to execute the cost function code due to an compilation error.\nSpecific: The function 'acceleration_costs' is actually a method owned by the class executing the code.\nStrategy: Turn function call into a method call by adding \"self.\"."
    },
    {
      "key": "!AN EXCEPTION OCCURRED!\nlist index out of range\nTYPE: <class 'IndexError'> METHOD: compute_curvilinear_coordinates LINE: c_tmp = cosys[i_c]",
      "value": "General: There is some fundamental problem within the planner. It does not produce any results.\nSpecific: In this case it is difficult to reason about the concrete problem.\nStrategy: Identify extreme weightings inside the cost function and correct them. Adopt a more conservative approach."
    }
  ]
}