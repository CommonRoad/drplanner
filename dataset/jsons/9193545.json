{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         cost = 0.0 \n         initial_lanelet_id = self.list_ids_lanelets_initial \n         cost_dist_to_goal = 0.0 \n         cost_time_to_goal = 0.0 \n         cost_velocity = 0.0 \n         cost_orientation = 0.0 \n         cost_acceleration = 0.0 \n         cost_yaw = 0.0 \n         cost_lanelet_offset = 0.0  \n         cost_lanelets_to_goal = 0 \n         cost_danger = 0.0 \n         current_path = node_current.list_paths[-1] \n         current_state = current_path[-1] \n         current_time_step = current_state.time_step \n         current_velocity = current_state.velocity \n         current_position = current_state.position \n         current_orientation = current_state.orientation \n         current_lanelet = None \n         travelled_dist = self.calc_travelled_distance(current_path) \n         dist_to_closest_obstacle_now = np.inf \n         dist_to_closest_obstacle_before = np.inf \n         begin_at = 0.75 # Begin the goal adjustment measures at part... \n         max_velocity = 20 \n         max_orientation = math.pi \n         sum_dist_centers_lanelets_crossed, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(current_path) \n         if self.reached_goal(current_path): \n             return 0.0 \n         # Find the current lanelet \n         if sum_dist_centers_lanelets_crossed is not None and final_lanelet_id is not None and start_lanelet_id is not None: \n             current_lanelet = self.scenario.lanelet_network.find_lanelet_by_id(final_lanelet_id[0]) \n         else: \n             current_lanelet = self.scenario.lanelet_network.find_lanelet_by_id(initial_lanelet_id[0]) \n         # Find the numbers of lanelets to goal \n         cost_lanelets_to_goal = self.dict_lanelets_costs[current_lanelet.lanelet_id] \n         # Find the closest obstacle on the current lanelet on current timestep and timestep before \n         dist_to_closest_obstacle_now = self.calc_dist_to_closest_obstacle(current_lanelet.lanelet_id, current_position, current_time_step) \n         if len(current_path) >= 3: \n                 dist_to_closest_obstacle_before = self.calc_dist_to_closest_obstacle(current_lanelet.lanelet_id, current_position, current_path[-2].time_step) # Be aware! The previous distance is computed according current state! \n         cost_danger = 5 * (math.exp(-dist_to_closest_obstacle_now) + math.exp(-dist_to_closest_obstacle_before)) \n         # Comfort mode; simple -> do not accelerate or break, less yaw if not needed (currently working only in survival mode) \n         if self.position_desired is None: \n             if len(current_path) >= 2: \n                 cost_acceleration = abs(current_path[-2].velocity - current_velocity) \n             else: \n                 cost_acceleration = max_velocity \n         if self.position_desired is None: \n             if len(current_path) >= 2: \n                 cost_yaw = abs(current_path[-2].orientation - current_orientation) \n             else: \n                 cost_yaw = max_orientation \n         # Lanelet offset -> better be closer to the center of current lanelet \n         cost_lanelet_offset = self.calc_distance_to_nearest_point(current_lanelet.center_vertices, current_position) \n         # Distance to the goal computation (working!) \n         if self.position_desired is not None: \n             cost_dist_to_goal = self.calc_euclidean_distance(current_node=node_current) \n         # Adjustments, if it is not the survival mode -> steer to the goal \n         if self.position_desired is not None: \n         # Velocity adjustment (working!) \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 if begin_at * self.distance_initial <= travelled_dist: \n                     # Begin to adjust the velocity to the goal velocity \n                     velocity_desired_mid = (self.velocity_desired.end -  self.velocity_desired.start)/2 \n                     cost_velocity = abs(current_velocity - velocity_desired_mid) \n                 else: \n                     # Constant cost \n                     cost_velocity = max_velocity \n         # Orientation adjustment (working!) \n             if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n                 if begin_at * self.distance_initial <= travelled_dist: \n                     # Begin to adjust the orietation to the goal orientation \n                     orientation_desired_mid = (self.orientation_desired.end -  self.orientation_desired.start)/2 \n                     cost_orientation = abs(current_orientation - orientation_desired_mid) \n                 else: \n                     # Constant cost \n                     cost_orientation = max_orientation \n         # Time cost \n         if self.position_desired is None: \n             cost_time_to_goal = self.time_desired.start - current_time_step \n         else: \n             if begin_at * self.distance_initial > travelled_dist: \n                 # Switch to the reckless mode \n                 if np.isclose(current_velocity, 0): \n                     cost_time_to_goal = np.inf \n                 else: \n                     cost_time_to_goal = self.calc_euclidean_distance(current_node=node_current) / current_velocity \n             else: \n                 cost_time_to_goal = 0.0 # The time is not important now, execute the steering to goal position (Can be improved) \n         # Estimating cost \n         cost = cost_dist_to_goal + cost_time_to_goal + cost_velocity + cost_orientation + cost_acceleration + cost_yaw + cost_lanelet_offset + cost_lanelets_to_goal + cost_danger \n         return cost",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost calculation uses arbitrary weights",
            "prescription": "Adjust weights for cost calculation according to relevance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         cost = 0.0 \n         initial_lanelet_id = self.list_ids_lanelets_initial \n         cost_dist_to_goal = 0.0 \n         cost_time_to_goal = 0.0 \n         cost_velocity = 0.0 \n         cost_orientation = 0.0 \n         cost_acceleration = 0.0 \n         cost_yaw = 0.0 \n         cost_lanelet_offset = 0.0 \n         cost_lanelets_to_goal = 0 \n         cost_danger = 0.0 \n         current_path = node_current.list_paths[-1] \n         current_state = current_path[-1] \n         current_time_step = current_state.time_step \n         current_velocity = current_state.velocity \n         current_position = current_state.position \n         current_orientation = current_state.orientation \n         travelled_dist = self.calc_travelled_distance(current_path) \n         dist_to_closest_obstacle_now = np.inf \n         dist_to_closest_obstacle_before = np.inf \n         begin_at = 0.75  # Begin the goal adjustment measures at part... \n         sum_dist_centers_lanelets_crossed, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet( \n             current_path) \n         if self.reached_goal(current_path): \n             return 0.0 \n         # Find the current lanelet \n         if sum_dist_centers_lanelets_crossed is not None and final_lanelet_id is not None and start_lanelet_id is not None: \n             current_lanelet = self.scenario.lanelet_network.find_lanelet_by_id(final_lanelet_id[0]) \n         else: \n             current_lanelet = self.scenario.lanelet_network.find_lanelet_by_id(initial_lanelet_id[0]) \n         # Find the numbers of lanelets to goal \n         cost_lanelets_to_goal = self.dict_lanelets_costs[current_lanelet.lanelet_id] \n         # Find the closest obstacle on the current lanelet on current timestep and timestep before \n         dist_to_closest_obstacle_now = self.calc_dist_to_closest_obstacle(current_lanelet.lanelet_id, current_position, \n                                                                           current_time_step) \n         cost_danger = 1/dist_to_closest_obstacle_now \n         # Comfort mode; simple -> do not accelerate or break, less yaw if not needed (currently working only in survival mode) \n         # Lanelet offset -> better be closer to the center of current lanelet \n         cost_lanelet_offset = self.calc_distance_to_nearest_point(current_lanelet.center_vertices, current_position) \n         # Distance to the goal computation (working!) \n         if self.position_desired is not None: \n             cost_dist_to_goal = self.calc_euclidean_distance(current_node=node_current) \n         # Adjustments, if it is not the survival mode -> steer to the goal \n         if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n             cost_orientation = self.calc_orientation_diff(self.calc_angle_to_goal(current_state), current_orientation) \n         # Begin to adjust the velocity to the goal velocity \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             velocity_desired_mid = (self.velocity_desired.end - self.velocity_desired.start) / 2 \n             cost_velocity = abs(current_velocity - velocity_desired_mid) \n         if self.position_desired is not None: \n             # Velocity adjustment (working!) \n                 if begin_at * self.distance_initial <= travelled_dist: \n                     cost_orientation *= 2 \n                     cost_velocity *= 2 \n         # Time cost \n         if self.position_desired is None: \n             cost_time_to_goal = self.time_desired.start - current_time_step \n         else: \n             cost_time_to_goal = self.calc_euclidean_distance(current_node=node_current) / current_velocity \n         path_efficiency = self.calc_path_efficiency(current_path) \n         if np.isclose(path_efficiency, 0): \n             return np.inf \n         # Estimating cost \n         cost = 2*cost_dist_to_goal + cost_time_to_goal + 0.2*cost_velocity + cost_orientation + cost_lanelet_offset + cost_lanelets_to_goal + 0.2*cost_danger + 100 - travelled_dist - 0.3*path_efficiency \n         return cost"
    }
}