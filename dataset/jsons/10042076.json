{
    "input": {
        "heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n\n        survival = False\n        multiplier = 1\n        alignment = 0\n        num_obst = 0\n\n\n        path_last = node_current.list_paths[-1]\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last)\n        distStartState = self.calc_heuristic_distance(path_last[0])\n        distLastStateManhattan = self.calc_heuristic_distance(path_last[-1], distance_type=1)\n        distLastStateEuclidean = self.calc_heuristic_distance(path_last[-1])\n\n        if len(path_last) > 5:\n            vel_avg = self.calc_path_efficiency(path_last[-5:]) * 10\n        else:\n            vel_avg = self.calc_path_efficiency(path_last) * 10\n\n        cur_lanelet = self.scenario.lanelet_network.find_lanelet_by_position([path_last[-1].position])[0][0]\n\n        if cur_lanelet is not None:\n            try:\n                num_obst = self.num_obstacles_in_lanelet_at_time_step(path_last[-1].time_step, cur_lanelet)\n                laneletObj = self.scenario.lanelet_network.find_lanelet_by_id(cur_lanelet)\n                llAngle = laneletObj.orientation_by_position(path_last[-1].position)\n                myAngle = path_last[-1].orientation\n                alignment = self.calc_orientation_diff(llAngle, myAngle)\n            except AssertionError:\n                alignment = 0\n\n        if self.position_desired is None:\n            survival = True\n\n        if survival:\n            # SURVIVAL PROBLEM, NO POSITION GOAL\n            if vel_avg > 40:\n                multiplier *= 100\n            elif survival and vel_avg < 1:\n                return np.inf\n            elif survival and vel_avg < 5:\n                multiplier *= 1000\n\n            if abs(alignment) > np.radians(45):\n                multiplier *= 500\n\n            weights_scores = np.array([[20, num_obst],\n                                       [10, max(0., 15. - vel_avg)],\n                                       [10, 10 * abs(alignment)]])\n        else:\n            # NOT SURVIVAL, GOAL-ORIENTED\n            time_total = 10 * get_last_time_step_in_scenario(self.scenario)\n            reqd_avg = distStartState / time_total\n\n            if distStartState < distLastStateEuclidean and not self.reached_goal(path_last):\n                multiplier *= 1e7\n\n            if vel_avg > 40 and not reqd_avg > 40:\n                multiplier *= 100\n            elif np.isclose(vel_avg, 0) and not np.isclose(reqd_avg, 0):\n                return np.inf\n\n            if self.reached_goal(path_last):\n                pc_cov = 1\n            else:\n                pc_cov = 1 - (distLastStateEuclidean / distStartState)\n\n            defEuclidean = self.calc_euclidean_distance(current_node=node_current)\n\n            if self.reached_goal(path_last):\n                return 0\n            elif defEuclidean < 0.5:\n                multiplier *= 1e-3\n                if cur_lanelet is not None:\n                    if self.is_goal_in_lane(cur_lanelet):\n                        multiplier *= 1e-2\n\n            if abs(alignment) > np.radians(45):\n                multiplier *= 1e4\n\n            weights_scores = np.array([[80, defEuclidean / path_last[-1].velocity],\n                                       [10, num_obst],\n                                       [10, defEuclidean],\n                                       [3, 100 * (1 - pc_cov)],\n                                       [1, max(0., reqd_avg - vel_avg)],\n                                       [1, 10 * abs(alignment)]])\n\n        return max(np.dot(weights_scores[:, 0], weights_scores[:, 1]) * multiplier, 0)\n"
    },
    "output": {
        "summary": [
            {
                "diagnosis": "High total cost",
                "prescription": "Adjust weights and multipliers"
            },
            {
                "diagnosis": "Zero velocity handling",
                "prescription": "Refine zero velocity conditions"
            },
            {
                "diagnosis": "Survival mode multiplier",
                "prescription": "Review survival mode logic"
            },
            {
                "diagnosis": "Alignment penalty",
                "prescription": "Calibrate alignment penalties"
            },
            {
                "diagnosis": "Goal proximity multiplier",
                "prescription": "Modify goal proximity logic"
            },
            {
                "diagnosis": "Redundant goal check",
                "prescription": "Remove redundant goal reached checks"
            }
        ],
        "improved_heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n        survival = False\n\n        multiplier = 1\n        alignment = 0\n        num_obst = 0\n\n        path_last = node_current.list_paths[-1]\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last)\n        distStartState = self.calc_heuristic_distance(path_last[0])\n        distLastStateManhattan = self.calc_heuristic_distance(path_last[-1], distance_type=1)\n        distLastStateEuclidean = self.calc_heuristic_distance(path_last[-1])\n\n        if len(path_last) > 5:\n            vel_avg = self.calc_path_efficiency(path_last[-5:]) * 10\n        else:\n            vel_avg = self.calc_path_efficiency(path_last) * 10\n\n        cur_lanelet = self.scenario.lanelet_network.find_lanelet_by_position([path_last[-1].position])[0][0]\n\n        if cur_lanelet is not None:\n            try:\n                num_obst = self.num_obstacles_in_lanelet_at_time_step(path_last[-1].time_step, cur_lanelet)\n                laneletObj = self.scenario.lanelet_network.find_lanelet_by_id(cur_lanelet)\n                llAngle = laneletObj.orientation_by_position(path_last[-1].position)\n                myAngle = path_last[-1].orientation\n                alignment = self.calc_orientation_diff(llAngle, myAngle)\n            except AssertionError:\n                alignment = 0\n\n        if self.position_desired is None:\n            survival = True\n\n        if survival:\n            # SURVIVAL PROBLEM, NO POSITION GOAL\n            if vel_avg > 40:\n                multiplier *= 10\n            elif survival and vel_avg < 1:\n                return np.inf\n            elif survival and vel_avg < 5:\n                multiplier *= 100\n\n            if abs(alignment) > np.radians(45):\n                multiplier *= 50\n\n            weights_scores = np.array([[10, num_obst],\n                                       [5, max(0., 15. - vel_avg)],\n                                       [5, 5 * abs(alignment)]])\n        else:\n            # NOT SURVIVAL, GOAL-ORIENTED\n            time_total = 10 * get_last_time_step_in_scenario(self.scenario)\n            reqd_avg = distStartState / time_total\n\n            if distStartState < distLastStateEuclidean and not self.reached_goal(path_last):\n                multiplier *= 1e5\n\n            if vel_avg > 40 and not reqd_avg > 40:\n                multiplier *= 10\n            elif np.isclose(vel_avg, 0) and not np.isclose(reqd_avg, 0):\n                return np.inf\n\n            if self.reached_goal(path_last):\n                return 0\n            else:\n                pc_cov = 1 - (distLastStateEuclidean / distStartState)\n\n            defEuclidean = self.calc_euclidean_distance(current_node=node_current)\n\n            if defEuclidean < 0.5:\n                multiplier *= 1e-2\n                if cur_lanelet is not None:\n                    if self.is_goal_in_lane(cur_lanelet):\n                        multiplier *= 1e-1\n\n            if abs(alignment) > np.radians(45):\n                multiplier *= 1e3\n\n            weights_scores = np.array([[40, defEuclidean / path_last[-1].velocity],\n                                       [5, num_obst],\n                                       [5, defEuclidean],\n                                       [1, 50 * (1 - pc_cov)],\n                                       [1, max(0., reqd_avg - vel_avg)],\n                                       [1, 5 * abs(alignment)]])\n\n        return max(np.dot(weights_scores[:, 0], weights_scores[:, 1]) * multiplier, 0)\n"
    }
}