{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         #derive the distance state \n         path_last = node_current.list_paths[-1] \n         distStartState = self.calc_heuristic_distance(path_last[0]) \n         #corresponding to weight[0], positional distance in guide \n         distLastState = self.calc_heuristic_distance(path_last[-1]) \n         if(distLastState is None) or (distStartState < distLastState): \n             return np.inf \n         #corresponding to weight[1], velocity difference in guide \n         if hasattr(self.planningProblem.goal.state_list[0],'velocity'): \n             v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start+self.planningProblem.goal.state_list[0].velocity.end)/2 \n             dist_vel = abs(path_last[-1].velocity - v_mean_goal) \n         else: \n             dist_vel = 0 \n         #corresponding to weight[2], orientation difference in guide \n         angleToGoal = self.calc_angle_to_goal(path_last[-1]) \n         orientationToGoalDiff = self.calc_orientation_diff(angleToGoal,path_last[-1].orientation) \n         #corresponding to weight[3], time diffenrence in guide \n         cost_time = self.calc_time_cost(path_last) \n         #corresponding to weight[4], trajectory efficiency in guide \n         pathEff = self.calc_path_efficiency(path_last) \n         pathLength = self.calc_travelled_distance(path_last) \n         #weights setting \n         weight = np.zeros(6) \n         weight[0] = 5 \n         weight[1] = 5 \n         weight[2] = 0.1 \n         weight[3] = 2 \n         weight[4] = 10 \n         weight[5] = 1 \n         #cost calculating \n         cost = weight[0]*distLastState +weight[1]*dist_vel +weight[2]*abs(orientationToGoalDiff) +weight[3]*cost_time +weight[4]*pathEff*0 +weight[5]*(100-pathLength) \n         if cost<0: \n             cost=1 \n         return cost",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost calculation uses arbitrary weights",
            "prescription": "Adjust weights for relevance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         # derive the distance state \n         path_last = node_current.list_paths[-1] \n         state = node_current.list_paths[-1][-1] \n         if self.position_desired is None: \n             return self.time_desired.start - state.time_step \n         else: \n             # corresponding to weight[0], positional distance in guide \n             distLastState = self.calc_heuristic_distance(path_last[-1]) \n             if distLastState is None: \n                 return np.inf \n             # corresponding to weight[1], velocity difference in guide \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 dist_vel = abs(path_last[-1].velocity - v_mean_goal) \n             else: \n                 dist_vel = 0 \n             if state.orientation not in self.orientation_desired: \n                 # corresponding to weight[2], orientation difference in guide \n                 angleToGoal = self.calc_angle_to_goal(path_last[-1]) \n                 orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, path_last[-1].orientation) \n                 orientationToGoalDiff = (orientationToGoalDiff + np.pi) % (2 * np.pi) - np.pi \n             else: \n                 orientationToGoalDiff = 0 \n             # corresponding to weight[3], time diffenrence in guide \n             cost_time = self.calc_time_cost(path_last) \n             # corresponding to weight[4], trajectory efficiency in guide \n             pathEff = self.calc_path_efficiency(path_last) \n             pathLength = self.calc_travelled_distance(path_last) \n             steering_angle_cost = self.calc_steering_angle_cost(node_current.list_paths[-1]) \n             # weights setting \n             weight = np.zeros(7) \n             weight[0] = 3 \n             weight[1] = 1 \n             weight[2] = 2 \n             weight[3] = 0.5 \n             weight[4] = 2 \n             weight[5] = 0.5 \n             weight[6] = 0.2 \n             # cost calculating \n             cost = weight[0] * distLastState + weight[1] * dist_vel + weight[2] * abs(orientationToGoalDiff) + weight[3] * cost_time + weight[4] * -pathEff + weight[5] * pathLength + weight[6] * steering_angle_cost \n             if cost < 0: \n                 cost = 1 \n             return cost"
    }
}