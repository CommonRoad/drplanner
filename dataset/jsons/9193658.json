{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path_last = node_current.list_paths[-1] \n         factor = 1 \n         f = 1 \n         distStartState = self.calc_heuristic_distance(path_last[0]) \n         distLastState = self.calc_heuristic_distance(path_last[-1]) \n         if distLastState is None: return np.inf \n         if distStartState < distLastState: factor = factor * 2 \n         if distLastState > 500   : f = 0.1 \n         if distLastState > 100   : f = 1 \n         elif distLastState > 50  : f = 10 \n         elif distLastState > 10  : f = 100 \n         else : f = 1000 \n         if distLastState > 500   : factor = factor * 1000 \n         elif distLastState > 100 : factor = factor * 100 \n         elif distLastState > 50  : factor = factor * 10 \n         elif distLastState > 10  : factor = factor * 1 \n         elif distLastState > 0.5 : factor = factor * 0.01 \n         else : factor = factor * 0.0001 \n         #time \n         if self.reached_goal(node_current.list_paths[-1]): return 0.0 \n         if self.position_desired is None: return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             if np.isclose(velocity, 0): return np.inf \n             else: cost_time = self.calc_euclidean_distance(current_node=node_current) / velocity \n         #collision \n         cost_collision = int(not self.is_collision_free(path_last)) \n         #lanelet \n         cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last) \n         if cost_lanelet is None or final_lanelet_id[0] is None: return np.inf \n         #orientation \n         angleToGoal = self.calc_angle_to_goal(path_last[-1]) \n         orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, path_last[-1].orientation) \n         cost_orientation = abs(orientationToGoalDiff) \n         #heuristic function \n         weights = np.zeros(4)  \n         weights[0] = 1 \n         weights[1] = 2 \n         weights[2] = 10 \n         weights[3] = 0.01 \n         cost = (1*f) * weights[0] * cost_time +  \n                (1/f) * weights[1] * cost_collision +  \n                (1*f) * weights[2] * (cost_lanelet / len(path_last)) +  \n                (1/f) * weights[3] * cost_orientation \n         if cost < 0: cost = 0 \n         return factor * cost",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost calculation uses arbitrary weights",
            "prescription": "Adapt weights for cost calculation according to relevance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path_last = node_current.list_paths[-1] \n         factor = 1 \n         f = 1 \n         distStartState = self.calc_heuristic_distance(path_last[0]) \n         distLastState = self.calc_heuristic_distance(path_last[-1]) \n         if distLastState is None: return np.inf \n         if distStartState < distLastState: factor = factor * 2 \n         #if distLastState != 0: \n         #    f = 1/distLastState \n         #    factor *= distLastState \n         # time \n         if self.reached_goal(node_current.list_paths[-1]): return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             cost_time = self.calc_euclidean_distance(current_node=node_current) / velocity \n         # collision \n         cost_collision = 0 \n         if len(path_last)>1 and not self.is_collision_free(path_last[1:]): \n             return np.inf \n         # lanelet \n         cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last) \n         if cost_lanelet is None or final_lanelet_id[0] is None: return np.inf \n         # orientation \n         angleToGoal = self.calc_angle_to_goal(path_last[-1]) \n         orientationToGoalDiff = 0 \n         if path_last[-1].orientation not in self.orientation_desired: \n             orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, path_last[-1].orientation) \n         cost_orientation = abs(orientationToGoalDiff) \n         path_eff = self.calc_path_efficiency(path_last) \n         # heuristic function \n         weights = np.zeros(4) \n         weights[0] = 2 \n         weights[1] = 2 \n         weights[2] = 3 \n         weights[3] = 0.8 \n         cost = ((1 * f) * weights[0] * cost_time + (1 / f) * weights[1] * cost_collision + (1 * f) * weights[2] * (cost_lanelet / len(path_last)) + (1 / f) * weights[3] * cost_orientation) * (1-0.2*path_eff) \n         if cost < 0: cost = 0 \n         return factor * cost"
    }
}