In addition to the methods described above, there are some pre-defined helper methods of the parent class:
```acceleration_costs(trajectory: TrajectorySample) -> float```,
```jerk_costs(trajectory: TrajectorySample) -> float```,
```lateral_jerk_costs(trajectory: TrajectorySample) -> float```,
```longitudinal_jerk_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories where the car does not use the steering wheel a lot
```orientation_offset_costs(trajectory: TrajectorySample) -> float```,
```steering_angle_costs(trajectory: TrajectorySample) -> float```,
```steering_velocity_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories which follow a straight line
```distance_to_reference_path_costs(trajectory: TrajectorySample) -> float```,
# Prefers short trajectories (similar to distance_to_reference_path)
```path_length_costs(trajectory: TrajectorySample) -> float```
When choosing from the pool of helper methods or adjusting their weights it is helpful to look at the cost evaluation as a reference.
Also keep in mind that the helper methods do not return normalized values and their return values can vary greatly in size.
When generating the cost function it is of utmost importance that a proper python method including signature and return statement is generated!

This is correct:
'''
def evaluate(self, trajectory: TrajectorySample) -> float:
    cost = 0.0

    # some calculation of cost...

    return cost
'''

This is false:
'''
cost = 0.0
# some calculation of cost...
'''

In addition to modifying the cost function, you can also modify the current planning horizon length by increasing the amount of discrete time-steps.
Initially, timestep-amount is set to 20.
It can be a number between 10 and 100 but if it is too large/small planning will fail!
However, long planning horizons can significantly improve performance in certain situations.