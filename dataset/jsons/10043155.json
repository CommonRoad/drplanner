{
    "input": {
        "heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode):\n        last_node = node_current.list_paths[-1]\n\n        # check for goal\n        if self.reached_goal(last_node):\n            # print(\"goal reached\")\n            return 0.0\n\n        # check if position is in lanelet\n        try:\n            lane_id = self.lanelet_network.find_lanelet_by_position([last_node[-1].position])[-1][-1]\n        except:\n            return np.inf\n\n        # crash\n        try:\n            if len(last_node) > 1 and not self.is_collision_free(last_node[1:-1]):\n                # print(\"collision\")\n                return np.inf\n        except:\n            print(\"fail collision check\")\n\n        # constants\n        f_vel_diff = 20\n        f_angle = 50\n        f_orient_diff = 50\n        f_steering_diff = 50\n        f_bench = 0\n\n        # variables\n        lane_id_init = self.lanelet_network.find_lanelet_by_position([last_node[0].position])[0][0]\n        lane_init = self.lanelet_network.find_lanelet_by_id(lane_id_init)\n        velocity_init = last_node[0].velocity\n        steering_init = last_node[0].steering_angle\n        orient_init = last_node[0].orientation\n\n        lane_id_end = self.lanelet_network.find_lanelet_by_position([last_node[-1].position])[-1][-1]\n        lane_end = self.lanelet_network.find_lanelet_by_id(lane_id_end)\n        velocity_end = last_node[-1].velocity\n        steering_end = last_node[-1].steering_angle\n        orient_end = last_node[-1].orientation\n\n        velocity_diff = abs(velocity_init - velocity_end)\n        orient_diff = abs(orient_init - orient_end)\n        steering_diff = abs(steering_init - steering_end)\n\n        try:\n            angle_init = self.calc_angle_of_position(lane_init.center_vertices, last_node[0].position)\n            angle_end = self.calc_angle_of_position(lane_end.center_vertices, last_node[-1].position)\n        except:\n            print(\"angle error\")\n            angle_init = 0\n            angle_end = 0\n\n        angle_diff = abs(angle_init - angle_end)\n\n        cost_bench = velocity_diff * f_vel_diff + angle_diff * f_angle + orient_diff * f_orient_diff + steering_diff * f_steering_diff\n\n        ######## current objective: surive ########\n\n        if self.position_desired is None:\n            # print(\"survival mode\")\n            time_to_survive = self.time_desired.start\n            time_survived = last_node[-1].time_step\n\n            if time_survived == time_to_survive:\n                cost = 0.0\n                return cost\n\n            nearest_obstacle_front, distance_object_front = StudentHelper.check_for_obstacle_infront(self, last_node,\n                                                                                                     lane_init)\n            nearest_obstacle_back, distance_object_back = StudentHelper.check_for_obstacle_back(self, last_node,\n                                                                                                lane_init)\n\n            speed_diff_infront = 0\n            speed_diff_behind = 0\n\n            if nearest_obstacle_front is not None or nearest_obstacle_back is not None:\n                # print(\"obstacle\")\n                if distance_object_front < 15 and distance_object_back > distance_object_front:\n                    # print(\"obstacle in front\")\n                    nearest_obstacle_velocity_front = nearest_obstacle_front.prediction.trajectory.state_list[\n                        last_node[-1].time_step].velocity\n                    speed_diff_infront = (velocity_end - nearest_obstacle_velocity_front) * distance_object_front / 10\n\n                if distance_object_back < 15 and distance_object_back < distance_object_front:\n                    # print(\"obstacle behind\")\n                    nearest_obstacle_velocity_behind = nearest_obstacle_back.prediction.trajectory.state_list[\n                        last_node[-1].time_step].velocity\n                    speed_diff_behind = (nearest_obstacle_velocity_behind - velocity_end) * distance_object_back / 10\n\n            return (time_to_survive - time_survived) + (speed_diff_behind + speed_diff_infront + f_bench * cost_bench)\n\n        ######### if there is a goal #########\n\n        # costs can calculate euclidean only if there is a goal\n        dist_goal = self.calc_euclidean_distance(current_node=node_current)\n        a_following = 0\n\n        # Check road conditions\n        # obstacle in front\n        nearest_obstacle, distance_object = StudentHelper.check_for_obstacle_infront(self, last_node, lane_init)\n        if self.is_goal_in_lane(lane_id):\n            if nearest_obstacle is not None:\n                # check if obstacle is slowing down\n                # nearest_obstacle_velocity = nearest_obstacle.prediction.trajectory.state_list[last_node[-1].time_step].velocity\n                # if under 10 just match velocity\n                if distance_object < 10:\n                    a_following = 1\n        # print(\"not in goal lane, cruising\")\n\n        return (dist_goal * (1 - a_following * (1 / (dist_goal + 0.00001))) + f_bench * cost_bench)\n"
    },
    "output": {
        "summary": [
            {
                "diagnosis": "Inefficient heuristic",
                "prescription": "Adjust the coefficient to enable its effect"
            },
            {
                "diagnosis": "Zero cost for goal state",
                "prescription": "Ensure non-zero heuristic for goal state to maintain consistency"
            }
        ],
        "improved_heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode):\n        last_node = node_current.list_paths[-1]\n\n        # check for goal\n        if self.reached_goal(last_node):\n            # print(\"goal reached\")\n            self.calc_path_efficiency(last_node)\n\n        # check if position is in lanelet\n        try:\n            lane_id = self.lanelet_network.find_lanelet_by_position([last_node[-1].position])[-1][-1]\n        except:\n            return np.inf\n\n        # crash\n        try:\n            if len(last_node) > 1 and not self.is_collision_free(last_node[1:-1]):\n                # print(\"collision\")\n                return np.inf\n        except:\n            print(\"fail collision check\")\n\n        # constants\n        f_vel_diff = 20\n        f_angle = 50\n        f_orient_diff = 50\n        f_steering_diff = 50\n        f_bench = 1  # Set to 1 to enable its effect, previously was 0\n\n\n        # variables\n        lane_id_init = self.lanelet_network.find_lanelet_by_position([last_node[0].position])[0][0]\n        lane_init = self.lanelet_network.find_lanelet_by_id(lane_id_init)\n        velocity_init = last_node[0].velocity\n        steering_init = last_node[0].steering_angle\n        orient_init = last_node[0].orientation\n\n        lane_id_end = self.lanelet_network.find_lanelet_by_position([last_node[-1].position])[-1][-1]\n        lane_end = self.lanelet_network.find_lanelet_by_id(lane_id_end)\n        velocity_end = last_node[-1].velocity\n        steering_end = last_node[-1].steering_angle\n        orient_end = last_node[-1].orientation\n\n        velocity_diff = abs(velocity_init - velocity_end)\n        orient_diff = abs(orient_init - orient_end)\n        steering_diff = abs(steering_init - steering_end)\n\n        try:\n            angle_init = self.calc_angle_of_position(lane_init.center_vertices, last_node[0].position)\n            angle_end = self.calc_angle_of_position(lane_end.center_vertices, last_node[-1].position)\n        except:\n            print(\"angle error\")\n            angle_init = 0\n            angle_end = 0\n\n        angle_diff = abs(angle_init - angle_end)\n\n        cost_bench = velocity_diff * f_vel_diff + angle_diff * f_angle + orient_diff * f_orient_diff + steering_diff * f_steering_diff\n\n        ######## current objective: surive ########\n\n        if self.position_desired is None:\n            # print(\"survival mode\")\n            time_to_survive = self.time_desired.start\n            time_survived = last_node[-1].time_step\n\n            if time_survived == time_to_survive:\n                cost = 0.0\n                return cost\n\n            nearest_obstacle_front, distance_object_front = StudentHelper.check_for_obstacle_infront(self, last_node,\n                                                                                                     lane_init)\n            nearest_obstacle_back, distance_object_back = StudentHelper.check_for_obstacle_back(self, last_node,\n                                                                                                lane_init)\n\n            speed_diff_infront = 0\n            speed_diff_behind = 0\n\n            if nearest_obstacle_front is not None or nearest_obstacle_back is not None:\n                # print(\"obstacle\")\n                if distance_object_front < 15 and distance_object_back > distance_object_front:\n                    # print(\"obstacle in front\")\n                    nearest_obstacle_velocity_front = nearest_obstacle_front.prediction.trajectory.state_list[\n                        last_node[-1].time_step].velocity\n                    speed_diff_infront = (velocity_end - nearest_obstacle_velocity_front) * distance_object_front / 10\n\n                if distance_object_back < 15 and distance_object_back < distance_object_front:\n                    # print(\"obstacle behind\")\n                    nearest_obstacle_velocity_behind = nearest_obstacle_back.prediction.trajectory.state_list[\n                        last_node[-1].time_step].velocity\n                    speed_diff_behind = (nearest_obstacle_velocity_behind - velocity_end) * distance_object_back / 10\n\n            return (time_to_survive - time_survived) + (speed_diff_behind + speed_diff_infront + f_bench * cost_bench)\n\n        ######### if there is a goal #########\n\n        # costs can calculate euclidean only if there is a goal\n        dist_goal = self.calc_euclidean_distance(current_node=node_current)\n        a_following = 0\n\n        # Check road conditions\n        # obstacle in front\n        nearest_obstacle, distance_object = StudentHelper.check_for_obstacle_infront(self, last_node, lane_init)\n        if self.is_goal_in_lane(lane_id):\n            if nearest_obstacle is not None:\n                # check if obstacle is slowing down\n                # nearest_obstacle_velocity = nearest_obstacle.prediction.trajectory.state_list[last_node[-1].time_step].velocity\n                # if under 10 just match velocity\n                if distance_object < 10:\n                    a_following = 1\n        # print(\"not in goal lane, cruising\")\n\n        return (dist_goal * (1 - a_following * (1 / (dist_goal + 0.00001))) + f_bench * cost_bench)\n"
    }
}