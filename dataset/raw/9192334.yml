input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             last_path = node_current.list_paths[-1] \n             velocity = last_path[-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             cost_lanelet, current_lanelet_id, _ = self.calc_heuristic_lanelet(last_path) \n             if cost_lanelet == -1: \n                 return np.inf \n             if node_current.list_paths[-1][-1].time_step is not None and self.planningProblem.goal.state_list[ \n                 0].time_step is not None and node_current.list_paths[-1][-1].time_step >  \n                     self.planningProblem.goal.state_list[0].time_step.end: \n                 return np.inf \n             heuristic = 0 \n             if current_lanelet_id is not None: \n                 number_of_obstacles = self.num_obstacles_in_lanelet_at_time_step(last_path[-1].time_step, \n                                                                                  current_lanelet_id[-1]) \n                 if number_of_obstacles > 0: \n                     closest_obstacle_distance_heuristic = ( \n                                 self.calc_dist_to_closest_obstacle(current_lanelet_id[-1], last_path[-1].position, \n                                                                    last_path[-1].time_step) + 0.001) \n             # normalized distance \n             distance_heuristic = self.calc_euclidean_distance(current_node=node_current) / self.distance_initial \n             distance_heuristic_factor = 5 \n             depth_heuristic = node_current.depth_tree \n             depth_heuristic_factor = 0.05 \n             # normalized orientation \n             orientation_heuristic = self.calc_orientation_diff( \n                 self.calc_angle_to_goal(node_current.list_paths[-1][-1]), \n                 node_current.list_paths[-1][-1].orientation \n             ) / np.pi \n             orientation_heuristic_factor = 2.5 \n             current_velocity = node_current.list_paths[-1][-1].velocity \n             velocity_heuristic = 0 \n             if current_velocity < self.velocity_desired.start: \n                 velocity_heuristic= abs(current_velocity - self.velocity_desired.start) / self.velocity_desired.start \n             elif current_velocity > self.velocity_desired.end: \n                 velocity_heuristic= abs(current_velocity - self.velocity_desired.end) / self.velocity_desired.end \n             velocity_heuristic_factor = 1 \n             heuristic += distance_heuristic * distance_heuristic_factor + depth_heuristic * depth_heuristic_factor + orientation_heuristic * orientation_heuristic_factor + velocity_heuristic * velocity_heuristic_factor \n             return heuristic \n "
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Insufficient weighting
    prescription: Adapt weighting to represent relevance
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n      penalty = 0 \n      if self.reached_goal(node_current.list_paths[-1]): \n          return 0.05 \n      time_heuristic = self.time_desired.start - node_current.list_paths[-1][-1].time_step \n      if self.time_desired.end is not np.inf and len(self.planningProblem.goal.state_list[0].attributes)==1: \n          return time_heuristic **2 \n      else: \n          last_path = node_current.list_paths[-1] \n          velocity = last_path[-1].velocity \n          if np.isclose(velocity, 0): \n              return np.inf \n          cost_lanelet, current_lanelet_id, _ = self.calc_heuristic_lanelet(last_path) \n          if cost_lanelet == -1: \n              return np.inf \n          heuristic = 0 \n          if current_lanelet_id is not None: \n              number_of_obstacles = self.num_obstacles_in_lanelet_at_time_step(last_path[-1].time_step, \n                                                                               current_lanelet_id[-1]) \n              penalty += number_of_obstacles \n          # normalized distance \n          distance_heuristic = self.calc_euclidean_distance(current_node=node_current) \n          # normalized orientation \n          orientation_heuristic = self.calc_orientation_diff( \n              self.calc_angle_to_goal(node_current.list_paths[-1][-1]), \n              node_current.list_paths[-1][-1].orientation \n          ) / np.pi \n          current_velocity = node_current.list_paths[-1][-1].velocity \n          velocity_heuristic = 0 \n          if current_velocity < self.velocity_desired.start: \n              velocity_heuristic = abs(current_velocity - self.velocity_desired.start) \n          elif current_velocity > self.velocity_desired.end: \n              velocity_heuristic = abs(current_velocity - self.velocity_desired.end) \n          path_efficiency = self.calc_path_efficiency(last_path) \n          distance_heuristic_factor = 0.5 \n          orientation_heuristic_factor = 0.3 \n          time_heuristic_factor = 0.25 \n          velocity_heuristic_factor = 0.1 \n          heuristic += distance_heuristic * distance_heuristic_factor + orientation_heuristic * orientation_heuristic_factor + velocity_heuristic * velocity_heuristic_factor + penalty - 0.1*path_efficiency \n          return heuristic"
