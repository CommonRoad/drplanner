{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.5 \n         factor = 1 \n         lastPath = node_current.list_paths[-1] \n         if self.calc_heuristic_distance(lastPath[-1]) > self.calc_heuristic_distance(lastPath[0]): \n             return np.inf \n         v3w3 = 0 \n         if self.position_desired is None: \n             estimatedTimeToGoal = self.time_desired.start - node_current.list_paths[-1][-1].time_step \n             v3w3 = estimatedTimeToGoal * 0.6 \n         # calculate the euclidian distance in m, default value is 0 \n         eDistanceToGoalV1 = 0 \n         v1w1 = 0 \n         if self.position_desired is not None: \n             eDistanceToGoalV1 = self.calc_euclidean_distance(current_node=node_current) \n             v1w1 = abs(eDistanceToGoalV1) * 0.7 \n         #change factor according to deviation in speed from avgspeed \n         speed = lastPath[-1].velocity \n         if np.isclose(speed, 0): \n             return np.inf \n         if self.position_desired is None: \n             return v3w3 / 0.3 / speed \n         #checks with the lanelet \n         cl, fl, sl = self.calc_heuristic_lanelet(lastPath) \n         if cl is not None: \n             if fl[0] is None: \n                 return np.inf \n             if fl[0] is not None: \n                 if fl[0] in self.list_ids_lanelets_goal: \n                     factor = factor * 0.2 \n                 travLanelets = [] \n                 self.is_goal_in_lane(fl[0], travLanelets) \n                 if not travLanelets: \n                     factor = factor * 1.9 \n                 else: \n                     factor = factor * 0.2 \n         return (v1w1 + v3w3) * factor",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Very high impact of multiplicative factors",
            "prescription": "Adapt weights of factor calculation"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0 \n         factor = 1 \n         lastPath = node_current.list_paths[-1] \n         if self.calc_heuristic_distance(lastPath[-1]) > self.calc_heuristic_distance(lastPath[0]): \n             return np.inf \n         estimatedTimeToGoal = 0 \n         v3w3 = 0 \n         if self.position_desired is None: \n             estimatedTimeToGoal = self.time_desired.start - node_current.list_paths[-1][-1].time_step \n             v3w3 = estimatedTimeToGoal * 0.6 \n         #--> changes factor from 1 to ( 0.7 - 1.7 ) depending on the estimated time distance to the goal \n         # calculate the euclidian distance in m, default value is 0 \n         eDistanceToGoalV1 = 0 \n         v1w1 = 0 \n         if self.position_desired is not None: \n             eDistanceToGoalV1 = self.calc_euclidean_distance(current_node=node_current) \n             v1w1 = abs(eDistanceToGoalV1) * 0.7 \n         #calculating the pov angle to the goal and make with a function a value out of it \n         angleToGoal = self.calc_angle_to_goal(lastPath[-1]) \n         v2w2 = 0 \n         if self.position_desired is not None and self.calc_euclidean_distance(current_node=node_current) > 8: \n             v2w2 = 18 \n         else: \n             v2w2 = 2.5 * pow((angleToGoal-math.pi), 2) \n         #change factor according to deviation in speed from avgspeed \n         avgSpeed = 0 \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             avgSpeed = (self.planningProblem.goal.state_list[0].velocity.start + self.planningProblem.goal.state_list[0].velocity.end) / 2 \n         speed = lastPath[-1].velocity \n         if np.isclose(speed, 0): \n             return np.inf \n         if self.position_desired is None: \n             return v3w3 / 0.3 / speed \n         if avgSpeed != 0: \n             if (avgSpeed/speed) >= 1: \n                 factor = factor * (avgSpeed / speed) \n             else: \n                 factor = factor * (2-(avgSpeed / speed)) \n         #checks with the lanelet \n         cl, fl, sl = self.calc_heuristic_lanelet(lastPath) \n         if cl is not None: \n             if fl[0] is None: \n                 return np.inf \n             if fl[0] is not None: \n                 if fl[0] in self.list_ids_lanelets_goal: \n                     factor = factor * 0.7 \n                 travLanelets = [] \n                 self.is_goal_in_lane(fl[0], travLanelets) \n                 if not travLanelets: \n                     factor = factor * 1.2 \n                 else: \n                     factor = factor * 0.6 \n         if hasattr(self.planningProblem.goal.state_list[0], 'time_step'): \n             goalTimeInterval = self.planningProblem.goal.state_list[0].time_step \n             avgTimeStep = (goalTimeInterval.start + goalTimeInterval.end)/2 \n             wTS = 0.0002 * pow((lastPath[-1].time_step - avgTimeStep), 2) \n             factor = factor * wTS \n         return (v1w1 + v2w2 + v3w3) * factor"
    }
}