input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         try: # errors are not logged properly, and I develop in Jupyter without debugging \n             heuristics = [] \n             weights    = [] \n             # In here, most of the code (and the general idea) is copied from the student_example file \n             # I incremently added parts and investigated the influence to the result \n             path_last = node_current.list_paths[-1] \n             start     = path_last[0] \n             goal      = path_last[-1] \n             distStartState = self.calc_heuristic_distance(start) \n             distLastState = self.calc_heuristic_distance(goal) \n             if distLastState is None: \n                 return np.inf \n             if distStartState < distLastState: \n                 return np.inf \n             # The default heuristic gets already pretty close to the target, so we begin with it \n             heuristics.append(super().heuristic_function(node_current)) \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                                self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 heuristics.append(goal.velocity - v_mean_goal) \n             else: \n                 heuristics.append(0.0) \n             angleToGoal = self.calc_angle_to_goal(goal) \n             heuristics.append(self.calc_orientation_diff(angleToGoal, goal.orientation)) \n             heuristics.append(self.calc_time_cost(path_last)) \n             weights.append(2) # previous heuristic distance / velocity \n             weights.append(1) # velocity difference \n             weights.append(1) # orientation difference \n             weights.append(1) # time difference \n             result = 0 \n             for i, h in enumerate(heuristics): \n                 result += weights[i] * abs(h) \n             return result \n         except Exception as err: \n             print(err)"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Mixture of independent factors
    prescription: Include distance to goal independent of velocity
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         try:  # errors are not logged properly, and I develop in Jupyter without debugging \n             heuristics = [] \n             weights = [] \n             # In here, most of the code (and the general idea) is copied from the student_example file \n             # I incremently added parts and investigated the influence to the result \n             path_last = node_current.list_paths[-1] \n             start = path_last[0] \n             goal = path_last[-1] \n             if self.reached_goal(node_current.list_paths[-1]): \n                 return 0.0 \n             if self.position_desired is None: \n                 return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n             # The default heuristic gets already pretty close to the target, so we begin with it \n             heuristics.append(self.calc_euclidean_distance(node_current))#super().heuristic_function(node_current)) \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                                self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 heuristics.append(goal.velocity - v_mean_goal) \n             else: \n                 heuristics.append(0.0) \n             if path_last[-1].orientation not in self.orientation_desired: \n                 angleToGoal = self.calc_angle_to_goal(goal) \n                 heuristics.append(self.calc_orientation_diff(angleToGoal, goal.orientation)) \n             else: \n                 heuristics.append(0) \n             heuristics.append(self.calc_time_cost(path_last)) \n             weights.append(2.5)  # previous heuristic distance / velocity \n             weights.append(0.8)  # velocity difference \n             weights.append(1)  # orientation difference \n             weights.append(1.5)  # time difference \n             path_eff = self.calc_path_efficiency(path_last) \n             result = 0 \n             for i, h in enumerate(heuristics): \n                 result += weights[i] * abs(h) \n             return result * (1 - 0.2*path_eff) \n         except Exception as err: \n             print(err)"
