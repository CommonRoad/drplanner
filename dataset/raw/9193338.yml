input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         self.parse_planning_problem() \n         if not hasattr(self.planningProblem.goal.state_list[0], 'position'): \n             efficiencyCost = self.calc_path_efficiency(node_current.list_paths[-1]) \n             weightedCosts = efficiencyCost**4 \n         else: \n             distCurTOGoal = self.calc_heuristic_distance(node_current.list_paths[-1][-1]) \n             distStartToGoal = self.calc_heuristic_distance(node_current.list_paths[-1][0]) \n             if hasattr(self.planningProblem.goal.state_list[0], 'time_step'): \n                 timeGoalInterval = self.time_desired \n                 timeIntervalMid = (timeGoalInterval.start + timeGoalInterval.end) / 2 \n                 timeDistanceCost = abs((distCurTOGoal / distStartToGoal) - ((node_current.list_paths[-1][-1].time_step - node_current.list_paths[-1][0].time_step) / timeIntervalMid)) \n             else: \n                 timeDistanceCost = 1 \n             weightedCosts = distCurTOGoal * timeDistanceCost**6 \n         return weightedCosts"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Cost calculation weights not adjusted for relevance
    prescription: Adapt factor weigths in cost calculation
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         self.parse_planning_problem() \n         state = node_current.list_paths[-1][-1] \n         path = node_current.list_paths[-1] \n         efficiencyCost = self.calc_path_efficiency(node_current.list_paths[-1]) \n         if np.isclose(efficiencyCost, 0): \n             return np.inf \n         if not hasattr(self.planningProblem.goal.state_list[0], 'position'): \n             time_diff = self.time_desired.start - node_current.list_paths[-1][-1].time_step \n             weightedCosts = efficiencyCost**-2 + time_diff \n         else: \n             distCurTOGoal = self.calc_heuristic_distance(node_current.list_paths[-1][-1]) \n             distStartToGoal = self.calc_heuristic_distance(node_current.list_paths[-1][0]) \n             if state.time_step not in self.time_desired: \n                 timeGoalInterval = self.time_desired \n                 timeIntervalMid = (timeGoalInterval.start + timeGoalInterval.end) / 2 \n                 timeDistanceCost = abs((distCurTOGoal / distStartToGoal) - ((node_current.list_paths[-1][-1].time_step - node_current.list_paths[-1][0].time_step) / timeIntervalMid)) \n             else: \n                 timeDistanceCost = 0 \n             travelled_distance = self.calc_travelled_distance(path) \n             orientation = state.orientation \n             if orientation not in self.orientation_desired: \n                 orientation_diff = abs(self.calc_orientation_diff(self.calc_angle_to_goal(state), orientation)) \n             else: \n                 orientation_diff = 0 \n             weightedCosts = distCurTOGoal + timeDistanceCost + 100 - travelled_distance + orientation_diff - 0.5*efficiencyCost \n         return weightedCosts \n "
