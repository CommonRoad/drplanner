input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = node_current.list_paths[-1] \n         if self.reached_goal(node_current.list_paths[-1]): \n             return  0.0 \n         #time difference \n         if self.position_desired is None: \n             c_time = self.time_desired.start - last_path[-1].time_step \n         else: \n             velocity = last_path[-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 c_time = self.calc_euclidean_distance(current_node=node_current) / velocity \n         #positional distance \n         c_position = self.calc_heuristic_distance(last_path[-1]) \n         #orientation difference \n         if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n             orientation_center = (self.orientation_desired.start + self.orientation_desired.end) / 2.0 \n             c_orientation = abs(self.calc_orientation_diff(last_path[-1].orientation, orientation_center)) \n         else: \n             c_orientation = 0 \n         #velocity difference \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             c_velocity = abs(last_path[-1].velocity - (self.velocity_desired.start + self.velocity_desired.end) / 2.0) \n         else: \n             c_velocity = 0 \n         w_time = 0.5 \n         w_position = 0.5 \n         w_orientation = 0.1 \n         w_velocity = 0.4 \n         cost = w_time * c_time + w_position * c_position + w_orientation * c_orientation + w_velocity * c_velocity \n         return cost"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Cost function uses arbitrary weights
    prescription: Adjust weigths for relevance
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = node_current.list_paths[-1] \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         #time difference \n         if self.position_desired is None: \n             c_time = self.time_desired.start - last_path[-1].time_step \n             #return c_time \n         else: \n             velocity = last_path[-1].velocity \n             c_time = self.calc_euclidean_distance(current_node=node_current) / velocity \n         #positional distance \n         c_position = 0 \n         if self.position_desired is not None: \n             c_position = self.calc_heuristic_distance(last_path[-1]) \n         #orientation difference \n         if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n             c_orientation = abs(self.calc_orientation_diff(last_path[-1].orientation, self.calc_angle_to_goal(last_path[-1]))) \n             c_orientation = (c_orientation + np.pi) % (2 * np.pi) - np.pi \n         else: \n             c_orientation = 0 \n         #velocity difference \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             c_velocity = abs(last_path[-1].velocity - (self.velocity_desired.start + self.velocity_desired.end) / 2.0) \n         else: \n             c_velocity = 0 \n         path_efficiency = self.calc_path_efficiency(last_path) \n         travelled_distance = self.calc_travelled_distance(last_path) \n         w_time = 0.3 \n         w_position = 3.0 \n         w_orientation = 0.7 \n         w_velocity = 0.3 \n         w_travelled_dist = 0.6 \n         w_path_efficiency = 2 \n         cost = (w_time * c_time + w_position * c_position + w_orientation * c_orientation + w_velocity * c_velocity + travelled_distance*w_travelled_dist - path_efficiency*w_path_efficiency) \n         return cost"
