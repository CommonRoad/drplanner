{
    "input": {
        "heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n        last_path = node_current.list_paths[-1]\n\n        distStartState = self.calc_heuristic_distance(last_path[0])\n        distLastState = self.calc_heuristic_distance(last_path[-1])\n\n        if self.reached_goal(last_path):\n            return 0.0\n\n        if distLastState is None:\n            print(32)\n            return numpy.inf\n\n        if distStartState < distLastState:\n            return self.calc_euclidean_distance(current_node=node_current)\n\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(last_path)\n\n        if cost_lanelet is None or final_lanelet_id[0] is None:\n            if hasattr(self.planningProblem.goal.state_list[0], 'time_step'):\n                return abs(last_path[-1].time_step - self.planningProblem.goal.state_list[0].time_step.start)\n            return numpy.inf\n\n        # Fastet path and closest to the destination\n        velocity = last_path[-1].velocity\n\n        if numpy.isclose(velocity, 0):\n            return numpy.inf\n        else:\n            try:\n                # A: time to reach goal\n                time_diff = self.calc_euclidean_distance(current_node=node_current) / velocity\n                # normalize: time to goal / (time until now + time to goal)\n                now_time = self.calc_time_cost(last_path)\n                time_diff = time_diff / ( now_time + time_diff )\n\n                # B: orientational diff to goal\n                angle = self.calc_angle_to_goal(last_path[-1])\n                orientation_diff = abs(self.calc_orientation_diff(angle, last_path[-1].orientation))\n                # normalize: orientation diff / 180\u00b0\n                orientation_diff = orientation_diff / math.pi\n\n                # C: velocity difference to goal\n                if hasattr(self.planningProblem.goal.state_list[0], 'velocity'):\n                    v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start +\n                           self.planningProblem.goal.state_list[0].velocity.end) / 2\n                    vel_diff = abs(last_path[-1].velocity - v_mean_goal)\n                else:\n                    vel_diff = 0\n\n                factor = 10\n                weights = numpy.zeros(3)\n                weights[0] = .49  # A: time to reach goal\n                weights[1] = .5   # B: orientation diff to goal\n                weights[2] = .01  # C: velocity difference\n                cost = weights[0] * time_diff +                        weights[1] * orientation_diff  +                        weights[2] * vel_diff\n\n                return cost * factor\n            except Exception as error:\n                print(error)\n                return distLastState\n"
    },
    "output": {
        "summary": [
            {
                "diagnosis": "Zero heuristic for goal",
                "prescription": "Remove zero heuristic for goal state"
            },
            {
                "diagnosis": "Infinite cost for zero velocity",
                "prescription": "Adjust infinite cost for zero velocity"
            },
            {
                "diagnosis": "Weights sum not equal to 1",
                "prescription": "Normalize weights to sum to 1"
            },
            {
                "diagnosis": "Zero weight for velocity difference",
                "prescription": "Increase weight for velocity difference"
            },
            {
                "diagnosis": "Neglecting acceleration and steering costs",
                "prescription": "Incorporate acceleration and steering costs"
            }
        ],
        "improved_heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n        last_path = node_current.list_paths[-1]\n\n        if self.reached_goal(last_path):\n            return self.calc_acceleration_cost(last_path) * 50.0 + self.calc_steering_angle_cost(last_path) * 50.0\n\n        distLastState = self.calc_heuristic_distance(last_path[-1])\n        if distLastState is None:\n            return numpy.inf\n\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(last_path)\n        if cost_lanelet is None or final_lanelet_id[0] is None:\n            return numpy.inf\n\n        velocity = last_path[-1].velocity\n        if numpy.isclose(velocity, 0):\n            velocity = 0.1  # Small positive value to avoid division by zero\n\n        time_diff = self.calc_euclidean_distance(current_node=node_current) / velocity\n        now_time = self.calc_time_cost(last_path)\n        time_diff = time_diff / (now_time + time_diff)\n\n        angle = self.calc_angle_to_goal(last_path[-1])\n        orientation_diff = abs(self.calc_orientation_diff(angle, last_path[-1].orientation))\n        orientation_diff = orientation_diff / math.pi\n\n        if hasattr(self.planningProblem.goal.state_list[0], 'velocity'):\n            v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start +\n                           self.planningProblem.goal.state_list[0].velocity.end) / 2\n            vel_diff = abs(last_path[-1].velocity - v_mean_goal)\n        else:\n            vel_diff = 0\n\n        weights = numpy.array([0.4, 0.4, 0.2])  # Normalized weights\n        cost = weights[0] * time_diff + weights[1] * orientation_diff + weights[2] * vel_diff\n\n        return cost * 10 + self.calc_acceleration_cost(last_path) * 50.0 + self.calc_steering_angle_cost(\n            last_path) * 50.0\n"
    }
}