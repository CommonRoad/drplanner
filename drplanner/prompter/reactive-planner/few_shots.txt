In addition to the methods described above, there are some pre-defined helper methods of the parent class:
```acceleration_costs(trajectory: TrajectorySample) -> float```,
```jerk_costs(trajectory: TrajectorySample) -> float```,
```lateral_jerk_costs(trajectory: TrajectorySample) -> float```,
```longitudinal_jerk_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories where the car does not use the steering wheel a lot
```orientation_offset_costs(trajectory: TrajectorySample) -> float```,
```steering_angle_costs(trajectory: TrajectorySample) -> float```,
```steering_velocity_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories which follow a straight line
```distance_to_reference_path_costs(trajectory: TrajectorySample) -> float```,
# Prefers short trajectories (similar to distance_to_reference_path)
```path_length_costs(trajectory: TrajectorySample) -> float```

Example:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:
        return 0.0
```
Improved result:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:
        cost = 0.0
        # own method
        cost += self.desired_velocity_costs(trajectory)
        # free style definition
        cost += (
            np.sum((0.25 * (self.desired_d - trajectory.curvilinear.d)) ** 2)
            + (20 * (self.desired_d - trajectory.curvilinear.d[-1])) ** 2
        )
        return cost
```

In addition to modifying the cost function, you can also modify the current planning horizon length by increasing the amount of discrete time-steps.
Initially, timestep-amount is set to 20.
It can be a number between 10 and 100 but if it is too large/small planning will fail!
However, long planning horizons can significantly improve performance in certain situations.