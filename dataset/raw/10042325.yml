input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         path_last = node_current.list_paths[-1] \n         if self.position_desired is None: \n             return self.time_desired.start - path_last[-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                                self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 dist_vel = abs(path_last[-1].velocity - v_mean_goal) \n             else: \n                 dist_vel = 0 \n             cost_time = 0.1 * self.calc_time_cost(path_last) \n             dist = self.calc_euclidean_distance(current_node=node_current) / velocity \n             return dist + cost_time + dist_vel"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
  - diagnosis: Inefficient survival mode
    prescription: Check if state in time goal interval not only at start of interval
  - diagnosis: Zero heuristic for goal
    prescription: Return value to evaluate path taken
  - diagnosis: Mixture of independent factors
    prescription: Include distance to goal independent of velocity
  - diagnosis: Neglect travelled distance
    prescription: Include travelled distance into cost function
  - diagnosis: Neglect path efficiency
    prescription: Include path efficiency into cost function
  - diagnosis: Inefficient weighting
    prescription: Adjust weights for relevance
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path = node_current.list_paths[-1] \n         state = path[-1] \n         path_efficiency = self.calc_path_efficiency(path) \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 2*(1/path_efficiency) \n         path_last = node_current.list_paths[-1] \n         if self.position_desired is None: \n             time_diff = 0 \n             if state.time_step not in self.time_desired: \n                 time_diff = abs(sum(self.time_desired)/2 - state.time_step) \n             return time_diff + 2*(1/path_efficiency) \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                                self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 dist_vel = abs(velocity - v_mean_goal) \n             else: \n                 dist_vel = 0 \n             cost_time = self.calc_time_cost(path_last) \n             dist = self.calc_euclidean_distance(current_node=node_current) \n             travelled_distance = self.calc_travelled_distance(path) \n             return 4*dist + 2*cost_time + 0.8*dist_vel + 10*1/path_efficiency + 0.8*travelled_distance"
