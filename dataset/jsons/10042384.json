{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path_last = node_current.list_paths[-1] \n         start_state = path_last[0] \n         last_state = path_last[-1] \n         dist_start_state = self.calc_heuristic_distance(start_state) \n         dist_last_state = self.calc_heuristic_distance(last_state) \n         # If we have reached the goal, finished \n         if self.reached_goal(path_last): \n             return 0.0 \n         # Make sure we didn't go pass the goal \n         if dist_start_state < dist_last_state: \n             return np.inf \n         # If we just have to 'survive' (Not reach any specific state) \n         # We just care how much left do we have to survive \n         if self.position_desired is None: \n             return self.time_desired.start - last_state.time_step \n         # WE ARE MOSTLY DOWN HERE: \n         # Most of the time we want to reach some final state \n         velocity = last_state.velocity \n         if np.isclose(velocity, 0): \n             return np.inf \n         cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last) \n         if cost_lanelet is None or final_lanelet_id[0] is None: # Maybe in this case change goal_in_lane , instead of returning inf? \n             return np.inf \n         # We want to be as close as possible to the goal state (euclidean distance) \n         rel_dist_to_goal = self.calc_euclidean_distance(current_node=node_current) / velocity \n         last_path_efficiency = self.calc_path_efficiency(path_last) \n         goal_in_lane = self.is_goal_in_lane(final_lanelet_id[0]) \n         weighted_variables = [(0.65, rel_dist_to_goal), \n                               (0.125, last_path_efficiency), \n                               (0.225, goal_in_lane) \n                               ] \n         pond_heuristics = sum([(w * var) for w, var in weighted_variables]) \n         return pond_heuristics \n ",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": [
            {
                "diagnosis": "Neglect orientation to goal difference",
                "prescription": "Include orientation to goal difference into cost function"
            },
            {
                "diagnosis": "Zero velocity handling",
                "prescription": "Don't return infinity if velocity is close to zero"
            },
            {
                "diagnosis": "Distance increase handling",
                "prescription": "Don't return infinity if distance to goal is bigger than initially"
            },
            {
                "diagnosis": "Zero heuristic for goal state",
                "prescription": "Don't return zero if goal state is reached"
            },
            {
                "diagnosis": "Inefficient weighting",
                "prescription": "Adjust weighting for relevance"
            },
            {
                "diagnosis": "Mixture of independent factors",
                "prescription": "Include distance to goal independent of velocity"
            }
        ],
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path_last = node_current.list_paths[-1] \n         start_state = path_last[0] \n         last_state = path_last[-1] \n         dist_start_state = self.calc_heuristic_distance(start_state) \n         dist_last_state = self.calc_heuristic_distance(last_state) \n         last_path_efficiency = self.calc_path_efficiency(path_last) \n         # If we just have to 'survive' (Not reach any specific state) \n         if self.position_desired is None: \n             return self.time_desired.start - last_state.time_step + (1/last_path_efficiency) \n         cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last) \n         if cost_lanelet is None or final_lanelet_id[0] is None: # Maybe in this case change goal_in_lane , instead of returning inf? \n             return np.inf \n         # We want to be as close as possible to the goal state (euclidean distance) \n         dist_to_goal = self.calc_euclidean_distance(current_node=node_current) \n         goal_in_lane = 0 if not self.is_goal_in_lane(final_lanelet_id[0]) else 1 \n         orientationToGoalDiff = self.calc_orientation_diff(self.calc_angle_to_goal(last_state), last_state.orientation) \n         orientationToGoalDiff = (orientationToGoalDiff + np.pi) % (2 * np.pi) - np.pi \n         weighted_variables = [(0.225, dist_to_goal), \n                               (0.35, 1/last_path_efficiency), \n                               (0.075, goal_in_lane), \n                               (0.35, orientationToGoalDiff) \n                               ] \n         pond_heuristics = sum([(w * var) for w, var in weighted_variables]) \n         return pond_heuristics"
    }
}