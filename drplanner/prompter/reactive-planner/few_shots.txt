The packages which you can access include:
```numpy as np```,

There are some pre-defined static helper methods of the CostFunction class which can be called in the heuristic function:
```acceleration_costs(trajectory: TrajectorySample) -> float```,
```jerk_costs(trajectory: TrajectorySample) -> float```,
```lateral_jerk_costs(trajectory: TrajectorySample) -> float```,
```longitudinal_jerk_costs(trajectory: TrajectorySample) -> float```,
```orientation_offset_costs(trajectory: TrajectorySample) -> float```,
```distance_to_reference_path_costs(trajectory: TrajectorySample) -> float```,
```path_length_costs(trajectory: TrajectorySample) -> float```

These are the getter functions for the TrajectorySample class:
```trajectory_long(self) -> PolynomialTrajectory```,
```trajectory_lat(self) -> PolynomialTrajectory```,
amount of states:
```length(self) -> int```,

These are the functions for the PolynomialTrajectory class where a state is represented as numpy array of floats of the form [p, p_dot, p_ddot]:
```evaluate_state_at_tau(self, tau: float)```,
goal state:
```x_d(self) -> np.ndarray```,
start state:
```x_0(self) -> np.ndarray```,

Example:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:

        # distance costs
        costs += (
            np.sum((0.25 * (self.desired_d - trajectory.curvilinear.d)) ** 2)
            + (20 * (self.desired_d - trajectory.curvilinear.d[-1])) ** 2
        )

        return cost
```
Improved result:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:

        costs = 0.0
        # acceleration costs
        costs += CostFunction.acceleration_costs(trajectory)

        # distance costs
        costs += (
            np.sum((0.25 * (self.desired_d - trajectory.curvilinear.d)) ** 2)
            + (20 * (self.desired_d - trajectory.curvilinear.d[-1])) ** 2
        )

        return cost
```