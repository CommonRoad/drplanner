input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float:   \n         path = node_current.list_paths[-1][-1] \n         pathLength = self.calc_travelled_distance(node_current.list_paths[-1]) \n         length = self.calc_heuristic_distance(path) \n         #if Distance couldn't be calculated: \n         if length is None: \n             return np.inf \n         # Velocity (I used the heuristic for best first search as basis): \n         if self.position_desired is None: \n             velocity = self.time_desired.start - node_current.list_paths[-1][-1].time_step             \n         else: \n             vel = path.velocity \n             if np.isclose(vel, 0): \n                  return np.inf \n             else: \n                 velocity = self.calc_euclidean_distance(current_node=node_current) / vel \n         # Orientation angle \n         angleToGoal = self.calc_angle_to_goal(path) \n         orientationToGoalDiff = abs(self.calc_orientation_diff(angleToGoal, path.orientation)) \n         # Time needed     \n         cost_time = self.calc_time_cost(node_current.list_paths[-1])         \n         return orientationToGoalDiff  + 8*velocity + cost_time + 15*(pathLength) \n    "
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
  - diagnosis: Neglect path efficiency
    prescription: Take path efficiency into consideration
  - diagnosis: Zero velocity handling
    prescription: Don't remove infinity if velocity is close to zero
  - diagnosis: Ignore full time interval
    prescription: Take full time interval into account not only start
  - diagnosis: No normalized orientation
    prescription: Normalize orientation before usage
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path = node_current.list_paths[-1] \n         state = path[-1] \n         pathLength = self.calc_travelled_distance(node_current.list_paths[-1]) \n         length = self.calc_heuristic_distance(state) \n         path_efficiency = self.calc_path_efficiency(path) \n         # if Distance couldn't be calculated: \n         if length is None: \n             return np.inf \n         # Velocity (I used the heuristic for best first search as basis): \n         if self.position_desired is None: \n             time_to_goal = 0 \n             if state.time_step not in self.time_desired: \n                 time_to_goal = abs(sum(self.time_desired) / 2 - state.time_step) \n         else: \n             vel = state.velocity \n             time_to_goal = self.calc_euclidean_distance(current_node=node_current) / vel \n         # Orientation angle \n         angleToGoal = self.calc_angle_to_goal(state) \n         orientationToGoalDiff = abs(self.calc_orientation_diff(angleToGoal, state.orientation)) \n         orientationToGoalDiff = (orientationToGoalDiff + np.pi) % (2 * np.pi) - np.pi \n         # Time needed \n         cost_time = self.calc_time_cost(node_current.list_paths[-1]) \n         return 10 * orientationToGoalDiff + 4 * time_to_goal + cost_time + 5 * (pathLength) + length + 5/path_efficiency"
