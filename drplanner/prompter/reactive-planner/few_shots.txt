In addition to the non-static methods described above, there are some pre-defined static helper methods of the CostFunction class:
```acceleration_costs(trajectory: TrajectorySample) -> float```,
```jerk_costs(trajectory: TrajectorySample) -> float```,
```lateral_jerk_costs(trajectory: TrajectorySample) -> float```,
```longitudinal_jerk_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories where the car does not use the steering wheel a lot
```orientation_offset_costs(trajectory: TrajectorySample) -> float```,
```steering_angle_costs(trajectory: TrajectorySample) -> float```,
```steering_velocity_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories which follow a straight line
```distance_to_reference_path_costs(trajectory: TrajectorySample) -> float```,
# Prefers short trajectories (similar to distance_to_reference_path)
```path_length_costs(trajectory: TrajectorySample) -> float```

Example:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:
        return 0.0
```
Improved result:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:
        cost = 0.0
        # static method
        cost += CostFunction.acceleration_costs(trajectory)
        # own method
        cost += self.desired_velocity_costs(trajectory)
        # free style definition
        cost += (
            np.sum((0.25 * (self.desired_d - trajectory.curvilinear.d)) ** 2)
            + (20 * (self.desired_d - trajectory.curvilinear.d[-1])) ** 2
        )
        return cost
```

In addition to modifying the cost function, you can also modify the current planning horizon length by increasing the amount of discrete timesteps.
Long planning horizons are particularly useful when driving long, straight paths