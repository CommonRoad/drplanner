{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         lastPathState = node_current.list_paths[-1] \n         if self.reached_goal(lastPathState): \n             return 0.0 \n         if self.position_desired is None: \n             time2goal = self.time_desired.start - lastPathState[-1].time_step \n         else: \n             velocity = lastPathState[-1].velocity \n             if np.isclose(velocity, 0): \n                 time2goal = np.inf \n             else: \n                 time2goal = self.calc_euclidean_distance(current_node=node_current) / velocity \n         orientation2goal = np.abs(self.calc_angle_to_goal(node_current.list_paths[-1][-1])) \n         return 0.84*time2goal + 0.16*orientation2goal",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Mixture of two different features",
            "prescription": "Use distance to goal also as an independent factor"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         lastPathState = node_current.list_paths[-1] \n         if self.reached_goal(lastPathState): \n             return 0.5 \n         time2goal = self.time_desired.start - lastPathState[-1].time_step \n         if self.position_desired is None: \n             return time2goal \n         else: \n             velocity = lastPathState[-1].velocity \n             vel_to_goal = 0 \n             if np.isclose(velocity, 0): \n                 time2goal = np.inf \n             dist_to_goal = self.calc_euclidean_distance(current_node=node_current) \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 vel_to_goal = abs((self.velocity_desired.start + self.velocity_desired.end)/2 - velocity) \n         orientation2goal = 0 \n         if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n             orientation2goal = np.abs(self.calc_angle_to_goal(node_current.list_paths[-1][-1])) \n         path_efficiency = self.calc_path_efficiency(node_current.list_paths[-1]) \n         return 0.3 * time2goal + 0.4*dist_to_goal + 0.15*vel_to_goal + 0.15 * orientation2goal - 0.2 * path_efficiency"
    }
}