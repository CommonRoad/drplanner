input:
  heuristic_function: "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n\n        factor = 1\n\n        path_last = self.shift_state(node_current.list_paths[-1])\n\n        ## GOAL ORIENTED COSTS\n\n        # Distance\n        delta_d = 0\n        if hasattr(self.planningProblem.goal.state_list[0], 'position'):\n            delta_d = self.find_closest_distance(path_last[-1].position, self.planningProblem.goal.state_list[0].position, self.optimize_distance)\n            delta_d_start = self.find_closest_distance(path_last[0].position, self.planningProblem.goal.state_list[0].position, self.optimize_distance)\n        else:\n            # Survival\n            delta_d = 0\n            delta_d_start = 0\n\n        # Time\n        delta_t = 0\n        current_time_step = path_last[-1].time_step\n        if self.planningProblem.goal.state_list[0].time_step is not None:\n            goal_time_step = self.planningProblem.goal.state_list[0].time_step\n            if isinstance(goal_time_step, int):\n                delta_t = abs(current_time_step - goal_time_step)\n            else:\n                if goal_time_step.contains(current_time_step):\n                    delta_t = 0\n                else:\n                    if goal_time_step.end < current_time_step:\n                        delta_t = abs(current_time_step - goal_time_step.end)\n                    else:\n                        delta_t = abs(goal_time_step.start - current_time_step)\n        else:\n            delta_t = current_time_step\n        \n        # Velocity\n        delta_v = 0\n        if hasattr(self.planningProblem.goal.state_list[0], \"velocity\"):\n            current_velocity = path_last[-1].velocity\n            goal_velocity = self.planningProblem.goal.state_list[0].velocity\n            if isinstance(goal_velocity, float):\n                delta_v = abs(current_velocity - goal_velocity)\n            else:\n                if goal_velocity.contains(current_velocity):\n                    delta_v = 0\n                else:\n                    if goal_velocity.end < current_velocity:\n                        delta_v = abs(current_velocity - goal_velocity.end)\n                    else:\n                        delta_v = abs(goal_velocity.start - current_velocity)\n\n        \n        # Orientation\n        delta_o = 0\n        if hasattr(self.planningProblem.goal.state_list[0], \"orientation\"):\n            current_orientation = path_last[-1].orientation\n            goal_orientation = self.planningProblem.goal.state_list[0].orientation\n            if isinstance(goal_orientation, float):\n                delta_o = abs(current_orientation - goal_orientation)\n            else:\n                if goal_orientation.contains(current_orientation):\n                    delta_o = 0\n                else:\n                    if goal_orientation.end < current_orientation:\n                        delta_o = abs(current_orientation - goal_orientation.end)\n                    else:\n                        delta_o = abs(goal_orientation.start - current_orientation)\n\n        ## COST ORIENTED COSTS (might not work as intended)\n\n        # Acceleration\n        a = 0\n        current_velocity = path_last[-1].velocity\n        if len(path_last) > 1:\n            previous_velocity = path_last[-2].velocity\n        else:\n            previous_velocity = self.planningProblem.initial_state.velocity\n        a = abs(current_velocity - previous_velocity)\n\n        # Steering angle \n        odt = 0\n        current_orientation = path_last[-1].orientation\n        if len(path_last) > 1:\n            previous_orientation = path_last[-2].orientation\n        else:\n            previous_orientation = self.planningProblem.initial_state.orientation\n        odt = abs(current_orientation - previous_orientation)\n\n        # Steering rate \n        odtt = 0\n        if len(path_last) > 1:\n            current_odt = path_last[-1].orientation - path_last[-2].orientation\n            if len(path_last) > 2:\n                previous_odt = path_last[-2].orientation - path_last[-3].orientation\n            else:\n                previous_odt = path_last[-2].orientation - self.planningProblem.initial_state.orientation\n            odtt = abs(current_odt - previous_odt)\n\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last)\n        if cost_lanelet is None:\n            cost_lanelet = 0\n\n        #angleToGoal = self.calc_angle_to_goal(path_last[-1])\n        #orientationToGoalDiff = abs(self.calc_orientation_diff(angleToGoal, path_last[-1].orientation))\n        #path_efficiency = self.calc_path_efficiency(path_last)\n        #pathLength = self.calc_travelled_distance(path_last)\n        #cost_time = self.calc_time_cost(path_last)\n        \n        if self.weights is None:\n            self.weights = [\n                1, #d\n                1, #t\n                1, #v\n                1, #o\n                .1, #a\n                0, #odt\n                0, #odtt\n                0, #L\n            ]\n\n        params = [\n            delta_d,\n            delta_t,#cost_time\n            delta_v,\n            delta_o,\n            a,\n            odt,\n            odtt,\n            cost_lanelet,\n            #abs(delta_d_start - pathLength),\n            #(cost_lanelet / len(path_last)),\n            #path_efficiency,\n            #num_obstacles_in_lane,\n            #goal_in_lane\n        ]\n\n        cost = np.dot(self.weights, params)\n\n        if cost < 0:\n            cost = 0\n\n        # Debug\n        padstr = '>' * len(node_current.list_paths) + ' ' * max(64-len(node_current.list_paths), 0)\n        #print(f\"{padstr}  d {delta_d:6.2f}  t {delta_t:6.2f}  o {delta_o:6.2f}  v {delta_v:6.2f}  a {a:6.2f}  odt {odt:6.2f}  odtt {odtt:6.2f}  L {cost_lanelet:6.2f}  O {orientations:6.2f}  =  p {(cost*factor):6.2f}  {self.reached_goal(node_current.list_paths[-1])}\")\n        \n        return cost * factor\n"
output:
  summary:
  - diagnosis: High acceleration cost
    prescription: Integrate existing calc_acceleration_cost to replace the code used for reducing acceleration cost
  - diagnosis: Inefficient path length cost
    prescription: Integrate calc_path_efficiency to optimize path length
  - diagnosis: Negligible steering angle cost
    prescription: Integrate calc_steering_angle_cost to adjust steering angle cost, replacing the code used in the heuristic function
  - diagnosis: Insignificant steering velocity cost
    prescription: Integrate calc_steering_velocity_cost to refine steering velocity cost
  - diagnosis: Zero weights for some costs
    prescription: Adjust weights to ensure all factors contribute to the heuristic
  - diagnosis: Cost can be negative
    prescription: Ensure cost is non-negative before returning
  improved_heuristic_function: "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n\n        factor = 1\n\n        path_last = self.shift_state(node_current.list_paths[-1])\n\n        ## GOAL ORIENTED COSTS\n\n        # Distance\n        delta_d = 0\n        if hasattr(self.planningProblem.goal.state_list[0], 'position'):\n            delta_d = self.find_closest_distance(path_last[-1].position, self.planningProblem.goal.state_list[0].position, self.optimize_distance)\n            delta_d_start = self.find_closest_distance(path_last[0].position, self.planningProblem.goal.state_list[0].position, self.optimize_distance)\n        else:\n            # Survival\n            delta_d = 0\n            delta_d_start = 0\n\n        # Time\n        delta_t = 0\n        current_time_step = path_last[-1].time_step\n        if self.planningProblem.goal.state_list[0].time_step is not None:\n            goal_time_step = self.planningProblem.goal.state_list[0].time_step\n            if isinstance(goal_time_step, int):\n                delta_t = abs(current_time_step - goal_time_step)\n            else:\n                if goal_time_step.contains(current_time_step):\n                    delta_t = 0\n                else:\n                    if goal_time_step.end < current_time_step:\n                        delta_t = abs(current_time_step - goal_time_step.end)\n                    else:\n                        delta_t = abs(goal_time_step.start - current_time_step)\n        else:\n            delta_t = current_time_step\n        \n        # Velocity\n        delta_v = 0\n        if hasattr(self.planningProblem.goal.state_list[0], \"velocity\"):\n            current_velocity = path_last[-1].velocity\n            goal_velocity = self.planningProblem.goal.state_list[0].velocity\n            if isinstance(goal_velocity, float):\n                delta_v = abs(current_velocity - goal_velocity)\n            else:\n                if goal_velocity.contains(current_velocity):\n                    delta_v = 0\n                else:\n                    if goal_velocity.end < current_velocity:\n                        delta_v = abs(current_velocity - goal_velocity.end)\n                    else:\n                        delta_v = abs(goal_velocity.start - current_velocity)\n\n        \n        # Orientation\n        delta_o = 0\n        if hasattr(self.planningProblem.goal.state_list[0], \"orientation\"):\n            current_orientation = path_last[-1].orientation\n            goal_orientation = self.planningProblem.goal.state_list[0].orientation\n            if isinstance(goal_orientation, float):\n                delta_o = abs(current_orientation - goal_orientation)\n            else:\n                if goal_orientation.contains(current_orientation):\n                    delta_o = 0\n                else:\n                    if goal_orientation.end < current_orientation:\n                        delta_o = abs(current_orientation - goal_orientation.end)\n                    else:\n                        delta_o = abs(goal_orientation.start - current_orientation)\n\n        # Acceleration\n        a = self.calc_acceleration_cost(path_last)\n        path_efficiency = self.calc_path_efficiency(path_last)\n        odt = self.calc_steering_angle_cost(path_last)\n        odtt = self.calc_steering_velocity_cost(path_last)\n\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last)\n        if cost_lanelet is None:\n            cost_lanelet = 0\n\n        #angleToGoal = self.calc_angle_to_goal(path_last[-1])\n        #orientationToGoalDiff = abs(self.calc_orientation_diff(angleToGoal, path_last[-1].orientation))\n        #path_efficiency = self.calc_path_efficiency(path_last)\n        #pathLength = self.calc_travelled_distance(path_last)\n        #cost_time = self.calc_time_cost(path_last)\n\n        if self.weights is None:\n            self.weights = [\n                1,  # d\n                1,  # t\n                1,  # v\n                1,  # o\n                1,  # a\n                1,  # odt\n                1,  # odtt\n                1,  # L\n                1,  # Efficiency\n            ]\n\n        params = [\n            delta_d,\n            delta_t,\n            delta_v,\n            delta_o,\n            a,\n            odt,\n            odtt,\n            cost_lanelet,\n            path_efficiency\n        ]\n\n        cost = np.dot(self.weights, params)\n\n        cost = max(cost, 0)\n\n        return cost * factor\n"
