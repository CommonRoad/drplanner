input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         ######################################################################## \n         # todo: Implement your own heuristic cost calculation here.            # \n         # Hint:                                                                # \n         #   Use the State of the current node and the information from the     # \n         #   planning problem, as well as from the scenario.                    # \n         #   Some helper functions for your convenience can be found in         # \n         #   ./search_algorithms/base_class.py                             # \n         ######################################################################## \n         path_fin = node_current.list_paths[-1] \n         distStart = self.calc_heuristic_distance(path_fin[0]) \n         distEnd = self.calc_heuristic_distance(path_fin[-1]) \n         if distEnd is None: \n             return np.inf \n         if distStart < distEnd: \n             return np.inf \n         cost_Of_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_fin) \n         if cost_Of_lanelet is None or final_lanelet_id[0] is None: \n             return np.inf \n         self.is_goal_in_lane(final_lanelet_id[0]) \n         Path_efficiency = self.calc_path_efficiency(path_fin) \n         self.num_obstacles_in_lanelet_at_time_step(path_fin[-1].time_step, final_lanelet_id[0]) \n         self.is_goal_in_lane(final_lanelet_id[0]) \n         angleToGoal = self.calc_angle_to_goal(path_fin[-1]) \n         pathLength = self.calc_travelled_distance(path_fin) \n         cost_time = self.calc_time_cost(path_fin) \n         orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, path_fin[-1].orientation) \n         if self.dict_lanelets_costs[final_lanelet_id[0]] == -1: \n             return np.inf \n         factor = 1 \n         if self.dict_lanelets_costs[final_lanelet_id[0]] > self.dict_lanelets_costs[start_lanelet_id[0]]: \n             return np.inf \n         if self.dict_lanelets_costs[final_lanelet_id[0]] < self.dict_lanelets_costs[start_lanelet_id[0]]: \n             factor = factor * 0.1 \n         if final_lanelet_id[0] in self.list_ids_lanelets_goal: \n             factor = factor * 0.05 \n         weights = np.zeros(7) \n         if distEnd < 1: \n             factor = factor * 0.00001 \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                            self.planningProblem.goal.state_list[0].velocity.end) / 2 \n             dist_vel = abs(path_fin[-1].velocity - v_mean_goal) \n         else: \n             dist_vel = 0 \n         weights[0] = 1 \n         weights[1] = 0.01 \n         weights[2] = 0.01 \n         weights[3] = 0.1 \n         weights[4] = 0.05 \n         weights[5] = 0.1 \n         weights[6] = 0.01 \n         cost = weights[0] * (cost_Of_lanelet / len(path_fin)) + weights[1] * abs(orientationToGoalDiff) + weights[2] * cost_time + weights[3] * distEnd +  weights[4] * (100 - pathLength) + weights[5] * dist_vel + weights[6] * Path_efficiency \n         if cost < 0: \n             cost = 0 \n         return cost * factor"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
  - diagnosis: Too high impact of factor
    prescription: Reduce the impact of the multiplicative factor
  - diagnosis: Handling of longer distance to goal
    prescription: Don't return infinity if distance to goal is longer than at the start
  - diagnosis: Ignoring potential cost features
    prescription: Use all the calculated features
  - diagnosis: Inefficient weighting
    prescription: Adjust weighting for relevance
  - diagnosis: No normalized orientation difference
    prescription: Normalize orientation difference before usage
  - diagnosis: Incorrect usage of path length
    prescription: Use path length to penalize long paths
  - diagnosis: Incorrect usage of path efficiency
    prescription: Use path efficiency to reward higher efficiencies
  - diagnosis: No survival mode
    prescription: Include a comparison of the current time step to the goal time
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path_fin = node_current.list_paths[-1] \n         distStart = self.calc_heuristic_distance(path_fin[0]) \n         distEnd = self.calc_heuristic_distance(path_fin[-1]) \n         factor = 1 \n         obs = 0 \n         cost_Of_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_fin) \n         if cost_Of_lanelet is not None or final_lanelet_id is not None: \n             if self.is_goal_in_lane(final_lanelet_id[0]): \n                 factor = factor*0.9 \n             obs = self.num_obstacles_in_lanelet_at_time_step(path_fin[-1].time_step, final_lanelet_id[0]) \n             if final_lanelet_id[0] in self.list_ids_lanelets_goal: \n                 factor = factor * 0.9 \n         else: \n             cost_Of_lanelet = 0 \n         Path_efficiency = self.calc_path_efficiency(path_fin) \n         angleToGoal = self.calc_angle_to_goal(path_fin[-1]) \n         pathLength = self.calc_travelled_distance(path_fin) \n         if hasattr(self.planningProblem.goal.state_list[0], 'time'): \n             cost_time = abs(self.time_desired.start - path_fin[-1].time_step) \n         else: \n             cost_time = self.calc_time_cost(path_fin) \n         orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, path_fin[-1].orientation) \n         orientationToGoalDiff = (orientationToGoalDiff + np.pi) % (2 * np.pi) - np.pi \n         weights = np.zeros(7) \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                            self.planningProblem.goal.state_list[0].velocity.end) / 2 \n             dist_vel = abs(path_fin[-1].velocity - v_mean_goal) \n         else: \n             dist_vel = 0 \n         weights[0] = 1 \n         weights[1] = 15 \n         weights[2] = 1 \n         weights[3] = 1.5 \n         weights[4] = 1 \n         weights[5] = 0.3 \n         weights[6] = 10 \n         cost = weights[0] * (cost_Of_lanelet) + weights[1] * abs(orientationToGoalDiff) + weights[2] * cost_time + weights[3] * distEnd + weights[4] * (pathLength) + weights[5] * dist_vel + weights[6] * 1/Path_efficiency + 0.2*obs \n         if cost < 0: \n             cost = 0 \n         return cost * factor"
