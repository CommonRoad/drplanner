{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 weights = [] \n                 path_last = node_current.list_paths[-1] \n                 # v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start +  \n                 #         self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 velocity_offset = 10 \n                 direct_time_to_goal = self.calc_euclidean_distance(current_node=node_current) / (velocity) \n                 #cost_time = self.calc_time_cost(node_current.list_paths[-1][-1]) \n                 # angleToGoal = self.calc_angle_to_goal(path_last[-1]) \n                 # orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, path_last[-1].orientation) \n                 # weights[0] = 0.85 \n                 # weights[1] = 0.15 \n                 cost = direct_time_to_goal # * weights[0] + orientationToGoalDiff * weights[1] \n                 if cost < 0: \n                     cost = 0 \n                 return cost",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost calculation uses arbitrary weights",
            "prescription": "Adjust weighting for balance and relevance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         current_state = node_current.list_paths[-1][-1] \n         path_last = node_current.list_paths[-1] \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.5 \n         time_diff = self.time_desired.start - current_state.time_step \n         if self.position_desired is None: \n             return time_diff \n         else: \n             velocity = current_state.velocity \n             velocity_diff = 0 \n             if velocity not in self.velocity_desired: \n                 velocity_diff = min(abs(velocity - self.velocity_desired.start), \n                                     abs(velocity - self.velocity_desired.end)) \n             path_eff = self.calc_path_efficiency(path_last) \n             if path_eff is np.inf: \n                 path_eff = 0 \n             path_eff = 1 - 0.2*path_eff \n             distance_goal = self.calc_euclidean_distance(current_node=node_current) \n             if self.time_desired.end is not np.inf: \n                 time_diff = min(0, abs(time_diff)) \n             else: \n                 time_diff = 0 \n             orientationToGoalDiff = 0 \n             if current_state.orientation not in self.orientation_desired: \n                 orientationToGoalDiff = self.calc_orientation_diff(current_state.orientation, self.orientation_desired.start) \n             cost = path_eff*(0.6*distance_goal + 0.2*time_diff + 0.1*orientationToGoalDiff + 0.1*velocity_diff) \n             if cost < 0: \n                 cost = 0 \n             return cost"
    }
}