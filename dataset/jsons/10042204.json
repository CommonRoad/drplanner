{
    "input": {
        "heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n\n        last_path = node_current.list_paths[-1]\n        goal_info = self.planningProblem.goal.state_list[0]\n\n        if self.reached_goal(last_path) == 1:\n            return 0.0\n        velocity = node_current.list_paths[-1][-1].velocity\n\n        if np.isclose(velocity, 0):\n            return np.inf\n    \n\n\n\n        # path heuristic caculation\n\n        #distLastState = self.calc_heuristic_distance(last_path[-1])\n\n\n\n        # Distance to obstacles\n\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(\n            last_path)\n    \n        if not(cost_lanelet is None or  start_lanelet_id[0] is None):\n            \n            dist_obstacle = self.calc_dist_to_closest_obstacle( start_lanelet_id[0],last_path[-1].position,last_path[-1].time_step)\n            n=self.num_obstacles_in_lanelet_at_time_step(last_path[-1].time_step, start_lanelet_id[0])\n            if np.isclose(dist_obstacle, 0.5) and n!=0:\n                return 1e7\n\n\n\n        # instantiate a route planner with the scenario and the planning problem\n        route_planner = RoutePlanner(self.scenario, self.planningProblem, backend=RoutePlanner.Backend.NETWORKX_REVERSED)\n        \n        # plan routes, and save the routes in a route candidate holder\n        candidate_holder = route_planner.plan_routes()\n        route = candidate_holder.retrieve_best_route_by_orientation()\n        \n        \n\n\n        #jerk optimal laternal\n\n        i_min=0\n        JOL=np.linalg.norm(route.reference_path[0]-last_path[-1].position)\n        for i in range(1,min(100,len(route.reference_path))):\n            _dist=self.distance(route.reference_path[i],last_path[-1].position)\n            if _dist<JOL :\n                JOL=_dist\n                i_min=i\n            else :\n                break\n           \n            \n            \n        # orientation difference\n        OD=abs(self.calc_orientation_diff(route.path_orientation[i_min],last_path[-1].orientation))\n\n        \n        # time difference\n        #TD = self.calc_time_cost(last_path)+distLastState/velocity-goal_info.time_step.start\n        \n        \n\n        # velocity difference\n        # VD = abs(goal_info.velocity.end-last_path[-1].velocity)\n        if hasattr(self.planningProblem.goal.state_list[0], 'velocity'):\n            #v_mean_goal = (goal_info.velocity.start + goal_info.velocity.end) / 2\n            VD = abs(goal_info.velocity.end-last_path[-1].velocity)\n        else:\n            VD = 0\n\n\n\n\n            \n\n\n        \n        cost =JOL + OD + VD\n        return cost\n"
    },
    "output": {
        "summary": [
            {
                "diagnosis": "Route planning inefficiency",
                "prescription": "Integrate pre-defined cost functions to enhance efficiency"
            },
            {
                "diagnosis": "Neglect of path efficiency",
                "prescription": "Incorporate calc_path_efficiency into heuristic"
            },
            {
                "diagnosis": "Neglect of acceleration cost",
                "prescription": "Incorporate calc_acceleration_cost into heuristic"
            },
            {
                "diagnosis": "Neglect of steering costs",
                "prescription": "Incorporate calc_steering_angle_cost and calc_steering_velocity_cost into heuristic"
            },
            {
                "diagnosis": "Redundant route planning affecting calculation efficiency",
                "prescription": "Optimize route planning by caching results"
            },
            {
                "diagnosis": "Zero velocity handling",
                "prescription": "Refine zero velocity condition to avoid infinite cost"
            },
            {
                "diagnosis": "Orientation difference scaling",
                "prescription": "Adjust orientation difference weight in heuristic"
            },
            {
                "diagnosis": "Velocity difference handling",
                "prescription": "Ensure velocity difference is always considered"
            }
        ],
        "improved_heuristic_function": "\n    def heuristic_function(self, node_current: PriorityNode) -> float:\n\n        last_path = node_current.list_paths[-1]\n        goal_info = self.planningProblem.goal.state_list[0]\n\n        if self.reached_goal(last_path) == 1:\n            return 0.0\n        velocity = node_current.list_paths[-1][-1].velocity\n\n        if np.isclose(velocity, 0):\n            velocity = 0.1  # Set a small non-zero velocity to avoid infinite cost\n\n        # path heuristic calculation\n        path_efficiency = self.calc_path_efficiency(last_path)\n        acceleration_cost = self.calc_acceleration_cost(last_path)\n        steering_angle_cost = self.calc_steering_angle_cost(last_path)\n        steering_velocity_cost = self.calc_steering_velocity_cost(last_path)\n\n        # Distance to obstacles\n        cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(last_path)\n\n        if not (cost_lanelet is None or start_lanelet_id[0] is None):\n            dist_obstacle = self.calc_dist_to_closest_obstacle(start_lanelet_id[0], last_path[-1].position,\n                                                               last_path[-1].time_step)\n            n = self.num_obstacles_in_lanelet_at_time_step(last_path[-1].time_step, start_lanelet_id[0])\n            if np.isclose(dist_obstacle, 0.5) and n != 0:\n                return 1e7\n\n        # Cache route planning results to avoid redundant calculations\n        if not hasattr(self, 'cached_route'):\n            route_planner = RoutePlanner(self.scenario, self.planningProblem,\n                                         backend=RoutePlanner.Backend.NETWORKX_REVERSED)\n            candidate_holder = route_planner.plan_routes()\n            self.cached_route = candidate_holder.retrieve_best_route_by_orientation()\n        route = self.cached_route\n\n        # Jerk optimal lateral\n        JOL = np.linalg.norm(route.reference_path[0] - last_path[-1].position)\n        for i in range(1, min(100, len(route.reference_path))):\n            _dist = self.distance(route.reference_path[i], last_path[-1].position)\n            if _dist < JOL:\n                JOL = _dist\n                i_min = i\n            else:\n                break\n\n        # Orientation difference\n        OD = abs(\n            self.calc_orientation_diff(route.path_orientation[i_min], last_path[-1].orientation)) * 0.5  # Adjust weight\n\n        # Velocity difference\n        if hasattr(goal_info, 'velocity'):\n            VD = abs(goal_info.velocity.end - last_path[-1].velocity)\n        else:\n            VD = 0\n\n        cost = path_efficiency + acceleration_cost + steering_angle_cost + steering_velocity_cost + JOL + OD + VD\n        return max(cost, 0)  # Ensure cost is non-negative\n"
    }
}