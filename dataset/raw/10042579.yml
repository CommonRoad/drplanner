input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = self.remove_states_behind_goal(node_current.list_paths)[-1] \n         PathFinalState = last_path[-1] \n         PathStartState = last_path[0] \n         velocity = PathFinalState.velocity \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         #dist to goal \n         #dist_goal = self.calc_euclidean_distance(current_node=node_current) \n         #time diff \n         if (self.position_desired is None): \n             required_time = self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             required_time = self.calc_euclidean_distance(current_node=node_current) \n         #angle diff \n         angle_goal = self.calc_angle_to_goal(PathFinalState) \n         diff_angle = self.calc_orientation_diff(PathFinalState.orientation,angle_goal) \n         #velocity diff \n         #diff_velocity = abs((self.velocity_desired.start +self.velocity_desired.end)/2 - velocity) \n         weights = np.ones(4) \n         weights[0] = 0.5 \n         weights[1] = 0.5 \n         weights[2] = 0.3 \n         weights[3] = 0.3 \n         cost =  weights[0]*required_time + weights[1]*diff_angle \n         return cost \n         pass"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
  - diagnosis: Missing normalization of orientation difference
    prescription: Normalize orientation difference before usage
  - diagnosis: Inefficient weighting
    prescription: Adjust weighting for relevance
  - diagnosis: Neglect of velocity difference
    prescription: Include velocity difference into cost function
  - diagnosis: Neglect of travelled distance
    prescription: Include travelled distance into cost function
  - diagnosis: Neglect of path efficiency
    prescription: Include path efficiency into cost function
  - diagnosis: Neglect of time cost
    prescription: Include time cost into cost function
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = self.remove_states_behind_goal(node_current.list_paths)[-1] \n         PathFinalState = last_path[-1] \n         PathStartState = last_path[0] \n         velocity = PathFinalState.velocity# \n         path_efficiency = self.calc_path_efficiency(last_path) \n         steering_cost = self.calc_steering_angle_cost(last_path) \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         # dist to goal \n         # dist_goal = self.calc_euclidean_distance(current_node=node_current) \n         # time diff \n         if (self.position_desired is None): \n             required_time = self.time_desired.start - node_current.list_paths[-1][-1].time_step + (1/path_efficiency)*5 + steering_cost \n         else: \n             required_time = self.calc_euclidean_distance(current_node=node_current) \n         # angle diff \n         angle_goal = self.calc_angle_to_goal(PathFinalState) \n         diff_angle = self.calc_orientation_diff(PathFinalState.orientation, angle_goal) \n         diff_angle = (diff_angle + np.pi) % (2 * np.pi) - np.pi \n         # velocity diff \n         diff_velocity = 0 \n         if velocity not in self.velocity_desired: \n             diff_velocity = abs((self.velocity_desired.start +self.velocity_desired.end)/2 - velocity) \n         travelled_dist = self.calc_travelled_distance(last_path) \n         cost_in_time = self.calc_time_cost(last_path) \n         weights = np.zeros(6) \n         weights[0] = 10 \n         weights[1] = 1 \n         weights[2] = 2 \n         weights[3] = 0.2 \n         weights[4] = 0.3 \n         weights[5] = 3 \n         cost = weights[0] * required_time + weights[1] * diff_angle + weights[2] * diff_velocity + weights[3]*cost_in_time + weights[4]*travelled_dist + weights[5]*(1/path_efficiency) \n         return cost \n         pass"
