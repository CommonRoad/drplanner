{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         distStartState = self.calc_heuristic_distance(node_current.list_paths[-1][0]) \n         distLastState = self.calc_heuristic_distance(node_current.list_paths[-1][-1]) \n         angleToGoal = self.calc_angle_to_goal(node_current.list_paths[-1][-1]) \n         if distLastState is None: \n             return np.inf \n         if distStartState < distLastState: \n             return np.inf \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             current_euclidean_distance = self.calc_euclidean_distance(current_node=node_current) \n             parameter_close_to_goal_distance=1-(current_euclidean_distance/ distStartState) \n             if parameter_close_to_goal_distance<0.7: \n                 weight_orientation=0 \n             else: \n                 weight_orientation=5 \n             orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, node_current.list_paths[-1][-1].orientation) \n             velocity = node_current.list_paths[-1][-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 return (current_euclidean_distance/ velocity)+(orientationToGoalDiff*weight_orientation)",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Mixture of independent factors",
            "prescription": "Include distance to goal independent to velocity"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         distStartState = self.calc_heuristic_distance(node_current.list_paths[-1][0]) \n         distLastState = self.calc_heuristic_distance(node_current.list_paths[-1][-1]) \n         angleToGoal = self.calc_angle_to_goal(node_current.list_paths[-1][-1]) \n         if distLastState is None: \n             return np.inf \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.5 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             current_euclidean_distance = self.calc_euclidean_distance(current_node=node_current) \n             parameter_close_to_goal_distance = 1 - (current_euclidean_distance / distStartState) \n             if parameter_close_to_goal_distance < 0.7: \n                 weight_orientation = 1 \n             else: \n                 weight_orientation = 2 \n             orientation = node_current.list_paths[-1][-1].orientation \n             orientationToGoalDiff = 0 \n             if orientation not in self.orientation_desired: \n                 orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, node_current.list_paths[-1][-1].orientation) \n             velocity = node_current.list_paths[-1][-1].velocity \n             vel_diff = 0 \n             if velocity not in self.velocity_desired: \n                 vel_diff = abs(sum(self.velocity_desired)/2 - velocity) \n             travelled_dist = 100 - self.calc_travelled_distance(node_current.list_paths[-1]) \n             path_eff = self.calc_path_efficiency(node_current.list_paths[-1]) \n             if np.isclose(path_eff, 0): \n                 return np.inf \n             return abs(weight_orientation*orientationToGoalDiff) + 2*current_euclidean_distance + travelled_dist + 0.2*vel_diff - 0.2*path_eff"
    }
}