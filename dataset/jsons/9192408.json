{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = node_current.list_paths[-1] \n         if self.reached_goal(last_path): \n             return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - last_path[-1].time_step \n         else: \n             velocity = last_path[-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 angleToGoal = self.calc_angle_to_goal(last_path[-1]) \n                 orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, last_path[-1].orientation) \n                 timeToGoal = self.calc_euclidean_distance(current_node=node_current) / velocity \n                 currentLaneletId = self.scenario.lanelet_network.find_lanelet_by_position([last_path[-1].position])[-1][-1] \n                 isInGoalLane = self.is_goal_in_lane(currentLaneletId) \n                 weights = np.zeros(10) \n                 weights[0] = 4.0 \n                 weights[1] = 10.0 \n                 weights[2] = 50.0 \n                 return timeToGoal * weights[0] + orientationToGoalDiff * weights[1] + (0.0 if isInGoalLane else 1.0) * weights[2]",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Mixture of different features",
            "prescription": "Use distance to goal independent of velocity"
        },
        "improved_heuristic_function": "     def heuristic_function(self, node_current: PriorityNode) -> float: \n         last_path = node_current.list_paths[-1] \n         if self.reached_goal(last_path): \n             return 0.5 \n         timeGoalDiff = (self.time_desired.start + self.time_desired.end)/2 - last_path[-1].time_step \n         if self.position_desired is None: \n             return timeGoalDiff **2 \n         else: \n             velocity = last_path[-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 angleToGoal = self.calc_angle_to_goal(last_path[-1]) \n                 pathEfficiency = self.calc_path_efficiency(last_path) \n                 if self.orientation_desired is not None: \n                     orientationToGoalDiff = self.calc_orientation_diff(angleToGoal, (self.orientation_desired.end + self.orientation_desired.start)/2)#last_path[-1].orientation) \n                 else: \n                     orientationToGoalDiff = 0 \n                 distToGoal = self.calc_euclidean_distance(current_node=node_current) \n                 diffToVelocityGoal = 0 \n                 if self.velocity_desired.end is not np.inf: \n                     diffToVelocityGoal = (self.velocity_desired.end + self.velocity_desired.start)/2 - velocity \n                 currentLaneletId = self.scenario.lanelet_network.find_lanelet_by_position([last_path[-1].position])[-1][ \n                     -1] \n                 isInGoalLane = self.is_goal_in_lane(currentLaneletId) \n                 weights = np.zeros(10) \n                 weights[0] = 2.5 # dist Goal \n                 weights[1] = 1.0 # orientation Goal \n                 weights[2] = 2.5 # time diff \n                 weights[3] = 1.5 # diffToVelocity \n                 return distToGoal * weights[0] + orientationToGoalDiff * weights[1] + (0.0 if isInGoalLane else 1.0) * (10/distToGoal) + weights[2]*timeGoalDiff + weights[3]*diffToVelocityGoal - (0.5*pathEfficiency if pathEfficiency is not np.inf else 0) \n "
    }
}