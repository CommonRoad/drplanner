{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 last_path = node_current.list_paths[-1] \n                 first_path = node_current.list_paths[0] \n                 cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(last_path) \n                 if cost_lanelet is None or final_lanelet_id[0] is None: \n                     return np.inf \n                 dist_score = self.calc_euclidean_distance(current_node=node_current) / velocity \n                 efficiency_score = self.calc_path_efficiency(last_path) \n                 angle_score = abs(self.calc_orientation_diff(self.calc_angle_to_goal(last_path[-1]), last_path[-1].orientation)) \n                 if hasattr(self.planningProblem.goal.state_list[0], 'time_step'): \n                     goal_time_delta = self.planningProblem.goal.state_list[0].time_step.end - last_path[-1].time_step \n                     if goal_time_delta < 0: \n                         return np.inf \n                 if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n                     orientation_delta = last_path[-1].orientation \n                     ori_mean = np.mean(np.array([self.planningProblem.goal.state_list[0].orientation.start, \n                                                  self.planningProblem.goal.state_list[0].orientation.end])) \n                     orientation_delta = abs(orientation_delta - ori_mean) \n                 else: \n                     orientation_delta = 0 \n                 if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                     path_length = self.calc_travelled_distance(last_path) \n                     v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                                 self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                     if path_length != 0: \n                         velocity_delta = abs(last_path[-1].velocity - v_mean_goal) / path_length \n                     else: \n                         velocity_delta = 0 \n                 else: \n                     velocity_delta = 0 \n                 weights = np.array([5.0,      0.7,              0.3,          max(1.0, 0.1/dist_score), max(1.0,1.0/dist_score)]) \n                 cost = np.array([dist_score, angle_score, efficiency_score, velocity_delta, orientation_delta]) \n                 cost = weights * cost \n                 return np.sum(cost)",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Mixed independent features",
            "prescription": "Include velocity and distance also as independent facotrs"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.5 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             velocity = node_current.list_paths[-1][-1].velocity \n             last_path = node_current.list_paths[-1] \n             first_path = node_current.list_paths[0] \n             cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(last_path) \n             if cost_lanelet is None or final_lanelet_id[0] is None: \n                 return np.inf \n             dist_score = self.calc_euclidean_distance(current_node=node_current) \n             efficiency_score = self.calc_path_efficiency(last_path) \n             if np.isclose(efficiency_score, 0): \n                 return np.inf \n             angle_score = 0 \n             if last_path[-1].orientation not in self.orientation_desired: \n                 angle_score = abs(self.calc_orientation_diff(self.calc_angle_to_goal(last_path[-1]), last_path[-1].orientation)) \n             if hasattr(self.planningProblem.goal.state_list[0], 'time_step'): \n                 goal_time_delta = self.planningProblem.goal.state_list[0].time_step.end - last_path[-1].time_step \n                 if goal_time_delta < 0: \n                     return np.inf \n             if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n                 orientation_delta = last_path[-1].orientation \n                 ori_mean = np.mean(np.array([self.planningProblem.goal.state_list[0].orientation.start, \n                                              self.planningProblem.goal.state_list[0].orientation.end])) \n                 orientation_delta = abs(orientation_delta - ori_mean) \n             else: \n                 orientation_delta = 0 \n             path_length = self.calc_travelled_distance(last_path) \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                             self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 if path_length != 0: \n                     velocity_delta = abs(last_path[-1].velocity - v_mean_goal) / path_length \n                 else: \n                     velocity_delta = 0 \n             else: \n                 velocity_delta = 0 \n             weights = np.array([2.0,      0.7,              0.3,          max(1.0, 5/dist_score), 1.0]) \n             cost = np.array([dist_score, angle_score, -efficiency_score, velocity_delta, 100 - path_length]) \n             cost = weights * cost \n             return np.sum(cost)"
    }
}