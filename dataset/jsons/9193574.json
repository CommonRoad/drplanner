{
    "input": {
        "heuristic_function": "  \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None:  # must be before calc_euclidean_distance \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         path_last = node_current.list_paths[-1] \n         distStartState = self.calc_heuristic_distance(path_last[0]) \n         distLastState = self.calc_heuristic_distance(path_last[-1]) \n         if distLastState is None: \n             return np.inf \n         if distStartState < distLastState: \n             return np.inf \n         ################################################# \n         # path_dist_from_start \n         travelled_dist_from_start = self.calc_travelled_distance(path_last) \n         # time_dist_from_start \n         time_dist_from_start = self.calc_time_cost(path_last) \n         # current_vel \n         current_vel = node_current.list_paths[-1][-1].velocity \n         valid_vel = current_vel \n         avg_vel_from_start = 0 \n         # avg_vel_from_start \n         if (time_dist_from_start > 2.0): \n             avg_vel_from_start = travelled_dist_from_start / time_dist_from_start \n             # valid_vel = avg_vel_from_start \n         if np.isclose(current_vel, 0): \n             return np.inf \n         if np.isclose(valid_vel, 0): \n             return np.inf \n         ##################################################### \n         # euclidean_dist_to_goal \n         euclidean_dist_to_goal = self.calc_euclidean_distance(current_node=node_current) \n         # estimated_time_distance to goal \n         time_dist_to_goal = euclidean_dist_to_goal / valid_vel \n         ######################################################## \n         ######################################################## \n         # orientation_diff \n         angle_to_goal = self.calc_angle_to_goal(path_last[-1]) \n         orientation_diff = abs(self.calc_orientation_diff(angle_to_goal, path_last[-1].orientation)) \n         ######################################################### \n         # obstacle on the lane \n         ########################################################## \n         # vel_diff = euclidean_distance(velocity_desired,current_node.list_paths[-1][-1].velocity) \n         ############################################################ \n         # time_dist_to_goal \n         # time_dist_from_start \n         # orientationToGoalDiff \n         # num_obstacles_current_lane/ \n         return time_dist_to_goal + 10 * orientation_diff",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost calculation uses arbitrary weights",
            "prescription": "Adapt cost function weights to relevance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None:  # must be before calc_euclidean_distance \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         path_last = node_current.list_paths[-1] \n         distStartState = self.calc_heuristic_distance(path_last[0]) \n         distLastState = self.calc_heuristic_distance(path_last[-1]) \n         if distLastState is None: \n             return np.inf \n         if distStartState < distLastState: \n             return np.inf \n         # path_dist_from_start \n         travelled_dist_from_start = self.calc_travelled_distance(path_last) \n         # euclidean_dist_to_goal \n         euclidean_dist_to_goal = self.calc_euclidean_distance(current_node=node_current) \n         # estimated_time_distance to goal \n         time_dist_to_goal = euclidean_dist_to_goal / path_last[-1].velocity \n         # orientation_diff \n         angle_to_goal = self.calc_angle_to_goal(path_last[-1]) \n         orientation_diff = abs(self.calc_orientation_diff(angle_to_goal, path_last[-1].orientation)) \n         path_efficiency = self.calc_path_efficiency(path_last) \n         if np.isclose(path_efficiency, 0): \n             return np.inf \n         return 2*time_dist_to_goal + orientation_diff + 100 - travelled_dist_from_start - 0.2*path_efficiency "
    }
}