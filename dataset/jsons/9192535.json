{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         weights = np.zeros(6) \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if not self.is_collision_free(node_current.list_paths[-1]): \n             return np.inf \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             path_last = node_current.list_paths[-1] \n             distStartState = self.calc_heuristic_distance(path_last[0]) \n             distLastState = self.calc_heuristic_distance(path_last[-1]) \n             if distStartState < distLastState: \n                 return np.inf \n             cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last) \n             if cost_lanelet is None or final_lanelet_id[0] is None:  ##check this one \n                 return np.inf \n             #num of obstacles on current lanelet \n             currentLaneletObj = self.scenario.lanelet_network.find_lanelet_by_id(final_lanelet_id[0]) \n             num_obst_in_lanelet = self.num_obstacles_in_lanelet_at_time_step(node_current.list_paths[-1][-1].time_step, final_lanelet_id[0]) \n             #Current lanelet = goal lanelet , reward such states? \n             #print(self.is_goal_in_lane(final_lanelet_id[0])) \n             if self.is_goal_in_lane(final_lanelet_id[0]):#final_lanelet_id[0] in self.list_ids_lanelets_goal: \n                 lanelet_factor = 0.1 \n             else: \n                 lanelet_factor = 1. \n             #Orientation difference to goal \n             if hasattr(self.planningProblem.goal.state_list[0], 'position'): \n                 angleToGoal = self.calc_angle_to_goal(path_last[-1]) \n                 angleDiff = abs(self.calc_orientation_diff(angleToGoal, path_last[-1].orientation)) \n             else : \n                 angleDiff = 0. \n             # compute velocity difference \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                                self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 velocityDiff = abs(path_last[-1].velocity - v_mean_goal) \n             else: \n                 velocityDiff = 0 \n             #Time step difference \n             if hasattr(self.planningProblem.goal.state_list[0], 'time_step'): \n                 t_mean_goal = (self.planningProblem.goal.state_list[0].time_step.start + \n                                self.planningProblem.goal.state_list[0].time_step.end) / 2 \n                 timeDiff = abs(node_current.list_paths[-1][-1].time_step - t_mean_goal) \n             else: \n                 timeDiff = 0 \n             weights[0]=2 \n             weights[1]=20 \n             weights[2]=1. \n             weights[3]=1 \n             weights[4]=0.2    \n             weights[5]=1. \n             cost = weights[0] * num_obst_in_lanelet +  \n                    weights[1] * angleDiff +  \n                    weights[2] * velocityDiff  +  \n                    weights[3] * self.calc_heuristic_distance(current_node=node_current) +  \n                    weights[4] * timeDiff \n             #print(f'c:{cost * lanelet_factor * (cost > 0 )}, nm_onst:{num_obst_in_lanelet}, anglDiff:{angleDiff},vDiff:{velocityDiff}, dist:{self.calc_euclidean_distance(current_node=node_current)}, lnlet_cost:{lanelet_factor},tmDiff:{timeDiff}') \n             return cost * lanelet_factor * (cost > 0 )",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Cost function uses arbitrary weights",
            "prescription": "Adjust weights to account for relevance and balance"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         weights = np.zeros(6) \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if len(node_current.list_paths[-1]) > 1 and not self.is_collision_free(node_current.list_paths[-1][1:]): \n             return np.inf \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             path_last = node_current.list_paths[-1] \n             #distStartState = self.calc_heuristic_distance(path_last[0]) \n             #distLastState = self.calc_heuristic_distance(path_last[-1]) \n             #if distStartState < distLastState: \n             #    return np.inf \n             cost_lanelet, final_lanelet_id, start_lanelet_id = self.calc_heuristic_lanelet(path_last) \n             if cost_lanelet is None or final_lanelet_id[0] is None:  ##check this one \n                 return np.inf \n             # num of obstacles on current lanelet \n             currentLaneletObj = self.scenario.lanelet_network.find_lanelet_by_id(final_lanelet_id[0]) \n             num_obst_in_lanelet = self.num_obstacles_in_lanelet_at_time_step(node_current.list_paths[-1][-1].time_step, \n                                                                              final_lanelet_id[0]) \n             # Current lanelet = goal lanelet , reward such states? \n             # print(self.is_goal_in_lane(final_lanelet_id[0])) \n             if self.is_goal_in_lane(final_lanelet_id[0]):  # final_lanelet_id[0] in self.list_ids_lanelets_goal: \n                 lanelet_factor = 0.8 \n             else: \n                 lanelet_factor = 1. \n             # Orientation difference to goal \n             if hasattr(self.planningProblem.goal.state_list[0], 'orientation'): \n                 angleToGoal = self.calc_angle_to_goal(path_last[-1]) \n                 angleDiff = abs(self.calc_orientation_diff(angleToGoal, path_last[-1].orientation)) \n             else: \n                 angleDiff = 0. \n             # compute velocity difference \n             if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n                 v_mean_goal = (self.planningProblem.goal.state_list[0].velocity.start + \n                                self.planningProblem.goal.state_list[0].velocity.end) / 2 \n                 velocityDiff = abs(path_last[-1].velocity - v_mean_goal) \n             else: \n                 velocityDiff = 0 \n             # Time step difference \n             if hasattr(self.planningProblem.goal.state_list[0], 'time_step'): \n                 t_mean_goal = (self.planningProblem.goal.state_list[0].time_step.start + \n                                self.planningProblem.goal.state_list[0].time_step.end) / 2 \n                 timeDiff = abs(node_current.list_paths[-1][-1].time_step - t_mean_goal) \n             else: \n                 timeDiff = 0 \n             distDiff = self.calc_heuristic_distance(node_current.list_paths[-1][-1]) \n             weights[0] = 2 \n             weights[1] = 2 \n             weights[2] = 1. \n             weights[3] = 5 \n             weights[4] = 3 \n             weights[5] = 1. \n             cost = weights[0] * num_obst_in_lanelet + weights[1] * angleDiff + weights[2] * velocityDiff + weights[3] * distDiff +  weights[4] * timeDiff \n             # print(f'c:{cost * lanelet_factor * (cost > 0 )}, nm_onst:{num_obst_in_lanelet}, anglDiff:{angleDiff},vDiff:{velocityDiff}, dist:{self.calc_euclidean_distance(current_node=node_current)}, lnlet_cost:{lanelet_factor},tmDiff:{timeDiff}') \n             return float(cost * lanelet_factor * (cost > 0))"
    }
}