The packages which you can access include:
```numpy as np```,

In addition to the non-static methods described above, there are some pre-defined static helper methods of the CostFunction class:
```acceleration_costs(trajectory: TrajectorySample) -> float```,
```jerk_costs(trajectory: TrajectorySample) -> float```,
```lateral_jerk_costs(trajectory: TrajectorySample) -> float```,
```longitudinal_jerk_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories where the car does not use the steering wheel a lot
```orientation_offset_costs(trajectory: TrajectorySample) -> float```,
# Prefers trajectories which follow a straight line
```distance_to_reference_path_costs(trajectory: TrajectorySample) -> float```,
# Prefers short trajectories (similar to distance_to_reference_path)
```path_length_costs(trajectory: TrajectorySample) -> float```

Example:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:
        return 0.0
```
Improved result:
```
    def evaluate(self, trajectory: TrajectorySample) -> float:
        cost = 0.0
        # static method
        cost += CostFunction.acceleration_costs(trajectory)
        # own method
        cost += self.desired_velocity_costs(trajectory)
        # free style definition
        cost += (
            np.sum((0.25 * (self.desired_d - trajectory.curvilinear.d)) ** 2)
            + (20 * (self.desired_d - trajectory.curvilinear.d[-1])) ** 2
        )
        return cost
```