input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         # a sample heuristic function from a previous random student \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         if np.isclose(node_current.list_paths[-1][-1].velocity, 0): \n                 return np.inf \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             factor = len(node_current.list_paths[-1])/100 \n             velocity = (1-factor) * self.planningProblem.goal.state_list[0].velocity.start + factor * self.planningProblem.goal.state_list[0].velocity.end \n             velocity = abs(node_current.list_paths[-1][-1].velocity - velocity) \n         else: \n             velocity = 0 \n         distance = self.calc_euclidean_distance(current_node=node_current)/node_current.list_paths[-1][-1].velocity \n         orientation = abs(self.calc_orientation_diff(self.calc_angle_to_goal(node_current.list_paths[-1][-1]), node_current.list_paths[-1][-1].orientation)) \n         time = self.calc_time_cost(node_current.list_paths[-1]) \n         return  distance + 1 * orientation + 0.5 * velocity + 1 * time \n "
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Zero cost for goal state
    prescription: Return small positive value if goal state is reached
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         # a sample heuristic function from a previous random student \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.5 \n         if self.position_desired is None: \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         if hasattr(self.planningProblem.goal.state_list[0], 'velocity'): \n             factor = len(node_current.list_paths[-1])/100 \n             velocity = (1-factor) * self.planningProblem.goal.state_list[0].velocity.start + factor * self.planningProblem.goal.state_list[0].velocity.end \n             velocity = abs(node_current.list_paths[-1][-1].velocity - velocity) \n         else: \n             velocity = 0 \n         distance = self.calc_euclidean_distance(current_node=node_current) \n         if node_current.list_paths[-1][-1].orientation not in self.orientation_desired: \n             orientation = abs(self.calc_orientation_diff(self.calc_angle_to_goal(node_current.list_paths[-1][-1]), node_current.list_paths[-1][-1].orientation)) \n         else: \n             orientation = 0 \n         time = self.calc_time_cost(node_current.list_paths[-1]) \n         path_eff = self.calc_path_efficiency(node_current.list_paths[-1]) \n         return (2*distance + 1 * orientation + 0.5 * velocity + 1 * time) * (1-0.25*path_eff)"
