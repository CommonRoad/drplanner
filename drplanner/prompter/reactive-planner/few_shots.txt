There are some pre-defined static helper methods of the CostFunction class which can be called in the heuristic function:
```def acceleration_costs(trajectory: TrajectorySample) -> float:```,
```def jerk_costs(trajectory: TrajectorySample) -> float:```,
```def lateral_jerk_costs(trajectory: TrajectorySample) -> float:```,
```def longitudinal_jerk_costs(trajectory: TrajectorySample) -> float:```,
```def orientation_offset_costs(trajectory: TrajectorySample) -> float:```,
```def distance_to_reference_path_costs(trajectory: TrajectorySample) -> float:```,
```def path_length_costs(trajectory: TrajectorySample) -> float:```

Example:
```
    def heuristic_function(self, node_current: PriorityNode) -> float:

        # distance costs
        costs += (
            np.sum((0.25 * (self.desired_d - trajectory.curvilinear.d)) ** 2)
            + (20 * (self.desired_d - trajectory.curvilinear.d[-1])) ** 2
        )

        return cost
```
Improved result:

Diagnosis: the acceleration is not considered
Prescription: add acceleration cost to the heuristic function
Diagnosis: the variable "costs" is never initialized
Prescription: add a local variable "costs"
```
    def heuristic_function(self, node_current: PriorityNode) -> float:

        costs = 0.0
        # acceleration costs
        costs += CostFunction.acceleration_costs(trajectory)

        # distance costs
        costs += (
            np.sum((0.25 * (self.desired_d - trajectory.curvilinear.d)) ** 2)
            + (20 * (self.desired_d - trajectory.curvilinear.d[-1])) ** 2
        )

        return cost
```