{
    "input": {
        "heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path = node_current.list_paths[-1] \n         goal = self.planningProblem.goal.state_list[0] \n         if self.reached_goal(path): \n             return 0.0 \n         path_init = path[0] \n         path_final = path[-1] \n         if hasattr(goal, 'position'): \n             ############################# DISTANCE #############################''' \n             dist_heuristic = 0 \n             dist_from_init = self.distance( \n                 path_init.position, goal.position.center, dist_heuristic \n             ) \n             dist_from_final = self.distance( \n                 path_final.position, goal.position.center, dist_heuristic \n             ) \n             # maybe penalize the case more when we are behind the goal? \n             cost_dist = dist_from_final \n             if dist_from_init - dist_from_final < 0: \n                 return np.inf \n             ########################### ORIENTATION ############################ \n             angle_to_goal = self.calc_angle_to_goal(path_final) \n             cost_orientation = abs(self.calc_orientation_diff( \n                 angle_to_goal, path_final.orientation \n             )) \n         else: \n             cost_dist = 0 \n             cost_orientation = 0 \n         ############################### VELOCITY ############################### \n         if hasattr(goal, 'velocity'): \n             goal_velocity_mean = (goal.velocity.start + goal.velocity.end) / 2 \n             cost_velocity = abs(goal_velocity_mean - path_final.velocity) \n         else: \n             cost_velocity = 0 \n         ################################# TIME ################################# \n         goal_mean_time = (goal.time_step.end + goal.time_step.start) / 2 \n         curr_time = path_final.time_step \n         cost_time = abs(goal_mean_time - path_final.time_step) \n         if curr_time > goal.time_step.end: \n             return np.inf \n         all_costs = [ \n             (cost_dist, 'distance'), \n             (cost_velocity, 'velocity'), \n             (cost_orientation, 'orientation'), \n             (cost_time, 'time') \n         ] \n         for cost, name in all_costs: \n             if cost < 0: \n                 raise Exception(f'Encountered negative cost {cost} ({name})') \n         total_cost = sum( \n             [cost * self.weights[name] for cost, name in all_costs]) \n         return total_cost \n ",
        "motion_primitives": "V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml"
    },
    "output": {
        "summary": {
            "diagnosis": "Neglect travelled distance",
            "prescription": "Include travelled distance into cost calculation"
        },
        "improved_heuristic_function": "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         self.weights = { \n             'distance': 1, \n             'velocity': 0.5, \n             'orientation': 1, \n             'time': 0.01, \n             'travelled_distance': 1, \n             'path_efficiency': -0.2 \n         } \n         path = node_current.list_paths[-1] \n         goal = self.planningProblem.goal.state_list[0] \n         if self.reached_goal(path): \n             return 0.0 \n         path_init = path[0] \n         path_final = path[-1] \n         if hasattr(goal, 'position'): \n             ############################# DISTANCE #############################''' \n             dist_heuristic = 0 \n             dist_from_init = self.distance( \n                 path_init.position, goal.position.center, dist_heuristic \n             ) \n             dist_from_final = self.distance( \n                 path_final.position, goal.position.center, dist_heuristic \n             ) \n             # maybe penalize the case more when we are behind the goal? \n             cost_dist = dist_from_final \n             ########################### ORIENTATION ############################ \n             cost_orientation = 0 \n             if path_final.orientation not in self.orientation_desired: \n                 angle_to_goal = self.calc_angle_to_goal(path_final) \n                 cost_orientation = abs(self.calc_orientation_diff( \n                     angle_to_goal, path_final.orientation \n                 )) \n         else: \n             cost_dist = 0 \n             cost_orientation = 0 \n         ############################### VELOCITY ############################### \n         if hasattr(goal, 'velocity'): \n             goal_velocity_mean = (goal.velocity.start + goal.velocity.end) / 2 \n             cost_velocity = abs(goal_velocity_mean - path_final.velocity) \n         else: \n             cost_velocity = 0 \n         ################################# TIME ################################# \n         cost_time = 0 \n         if path_final.time_step not in self.time_desired: \n             goal_mean_time = (goal.time_step.end + goal.time_step.start) / 2 \n             curr_time = path_final.time_step \n             cost_time = abs(goal_mean_time - path_final.time_step) \n             if curr_time > goal.time_step.end: \n                 return np.inf \n         path_efficiency = self.calc_path_efficiency(path) \n         travelled_distance = 100 - self.calc_travelled_distance(path) \n         all_costs = [ \n             (cost_dist, 'distance'), \n             (cost_velocity, 'velocity'), \n             (cost_orientation, 'orientation'), \n             (cost_time, 'time'), \n             (travelled_distance, 'travelled_distance'), \n             (path_efficiency, 'path_efficiency'), \n         ] \n         for cost, name in all_costs: \n             if cost < 0: \n                 raise Exception(f'Encountered negative cost {cost} ({name})') \n         total_cost = sum( \n             [cost * self.weights[name] for cost, name in all_costs]) \n         return total_cost"
    }
}