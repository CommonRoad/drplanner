input:
  heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             #e.g. self.scenatio.dt = 0.1, self.time_desired.start=33 \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             count = 0 \n             velocity = node_current.list_paths[-1][-1].velocity \n             if velocity in self.velocity_desired: \n                 count += 1 \n             distance_to_goal = self.calc_euclidean_distance(current_node=node_current) \n             if np.isclose(velocity, 0): \n                 return np.inf \n             else: \n                 time_to_goal = distance_to_goal / velocity \n                 # returns id of the start lanelet \n                 cur_lanelet_id = self.scenario.lanelet_network.find_lanelet_by_position([node_current. \n                                                                                            list_paths[-1][-1].position])[0] \n                 if not cur_lanelet_id: \n                     return time_to_goal \n                 else: \n                     time_step = node_current.list_paths[-1][-1].time_step \n                     lanelet_id = cur_lanelet_id[0] \n                     pos = node_current.list_paths[-1][-1].position \n                     obstacles_in_lanelet = self.get_obstacles( \n                         self.scenario.lanelet_network.find_lanelet_by_id(lanelet_id),  \n                         time_step) \n                     shortestDist = math.inf \n                     for obstacleObj in obstacles_in_lanelet: \n                         shape_obs = obstacleObj.occupancy_at_time(time_step).shape \n                         if isinstance(shape_obs, Circle): \n                             if self.distance(pos, shape_obs.center) < shortestDist: \n                                 shortestDist = self.distance(pos, shape_obs.center) \n                         elif isinstance(shape_obs, Rectangle): \n                             if self.distance(pos, shape_obs.center) < shortestDist: \n                                 shortestDist = self.distance(pos, shape_obs.center) \n                     if shortestDist > 10: \n                         count += 2 \n                     if any(id in cur_lanelet_id for id in self.list_ids_lanelets_goal): \n                         count += 3 \n                     orientation = node_current.list_paths[-1][-1].orientation \n                     if orientation in self.orientation_desired: \n                         count += 1 \n                 score = time_to_goal*(1-0.1*count) \n                 return score"
  motion_primitives: V_0.0_20.0_Vstep_4.0_SA_-1.066_1.066_SAstep_0.18_T_0.5_Model_BMW_320i.xml
output:
  summary:
    diagnosis: Neglect travelled distance
    prescription: Include travelled distance into cost function
  improved_heuristic_function: "    def heuristic_function(self, node_current: PriorityNode) -> float: \n         path = node_current.list_paths[-1] \n         state = node_current.list_paths[-1][-1] \n         if self.reached_goal(node_current.list_paths[-1]): \n             return 0.0 \n         if self.position_desired is None: \n             # e.g. self.scenatio.dt = 0.1, self.time_desired.start=33 \n             return self.time_desired.start - node_current.list_paths[-1][-1].time_step \n         else: \n             count = 0 \n             velocity = node_current.list_paths[-1][-1].velocity \n             if velocity in self.velocity_desired: \n                 count += 1 \n             distance_to_goal = self.calc_euclidean_distance(current_node=node_current) \n             path_efficiency = self.calc_path_efficiency(path) \n             travelled_distance = self.calc_travelled_distance(path) \n             # returns id of the start lanelet \n             cur_lanelet_id = self.scenario.lanelet_network.find_lanelet_by_position([node_current. \n                                                                                  list_paths[-1][-1].position])[0] \n             orientation_difference = 0 \n             if state.orientation not in self.orientation_desired: \n                 orientation_difference = self.calc_orientation_diff(self.calc_angle_to_goal(state), state.orientation) \n                 orientation_difference = (orientation_difference + np.pi) % (2 * np.pi) - np.pi \n             heuristic = 3*distance_to_goal + travelled_distance - 2*path_efficiency + orientation_difference \n             if not cur_lanelet_id: \n                 return heuristic \n             else: \n                 lanelet_id = cur_lanelet_id[0] \n                 shortestDist = self.calc_dist_to_closest_obstacle(lanelet_id, state.position, state.time_step) \n                 if shortestDist > 10: \n                     count += 0.5 \n                 if any(id in cur_lanelet_id for id in self.list_ids_lanelets_goal): \n                     count += 1 \n             score = heuristic * (1 - 0.1 * count) \n             return score"
